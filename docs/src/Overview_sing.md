```@meta
CurrentModule = Feynman
```
## OVERVIEW:

We generate the Feynman integrand associated to a Feynman diagram and compute reduced IBP system to reduce given target integers to master integrals.

## KEYWORDS:

Feynman integral;

## PROCEDURES:

**makeGraph(list, list)**                                   generate a graph from a list of vertices and a list of edges
**makeLabeledGraph(list, list)**                            generate a labeled graph from a list of vertices and a list of edges
**printGraph(graph)**                                       print procedure for graphs
**labelGraph(graph)**                                       label a graph with variables for vertices and edges
**balancingIdeal(labeledgraph)**                            ideal of balancing conditions
**eliminateVariables(labeledgraph)**                        eliminate variables according to balancing condition
**propagators(labeledgraph)**         	                    generate ideal generated by denominators of the Feynman integral assocated to graph
**ISP(labeledgraph)**			                                  extend the propagators to a basis of the quadratic forms
**removeElimVars(labeledgraph)**                            Removes the variables from G.elimvars. This key is generated by the procedure **eliminateVariables(labeledgraph)**
**computeBaikovMatrix(graph)**                              computes the Baikov matrix of G defined in G1.baikovover and stores it in G1.baikovmatrix
**computeM1(labeledgraph)**                                 generate the module M1 over G1.baikovover that requires to compute IBP identities 
**computeM2(labeledgraph,list)**                            generate the module M2 over G1.baikovover that requires to compute IBP identities 
**computeIBP(labeledgraph,list)**                           generate the set of IBPS correspond to the given indices of denominators of the feynman 
                                                            integral.
**getSector(list)**                                         returns the sector (a list of 1s and 0s) that the integral belongs
**listCombintions(list,int)**                               returns the list of r-combinations of the elements in the list L
**generateWebSectors(list)**                                generate the Web structure of the sectors L, where L is the list and L[1] is the sector 
                                                            that correspond to the seed and L[i]  contain the subsectors of the sectors in L[i-1]. Not 
                                                            that sector maps between the sectors have not been setted.
**isSubList(l1,l2)**                                        return 1 if elements in l1 contain in l2  0 if elements in l1 do not contain in l2
**getSectorMap(L1,L2)**                                     L1 where sectorMap  of each sector in the list L1 is filled.
**setSectorMap(sectorWeb)**                                 sectorWeb where the field sectorMap field of each sector in sectorWeb is filled.
**findSector(sectorWeb,currentPosition,L)**                 return position of the sector in the sectorWeb, where the L belongs. return -1, if the 
                                                            sector is not found
**updateOneSector(sectorWeb,currentPosition,oneInt)**       updated sectorWeb, where the oneInt is assigned to the targetInts field of the seector 
                                                            correspond to provided oneInt
**updateWeb(sectorWeb,currentPosition,setInt)**             return a list(sectorWeb,MasterInt,notInWeb) where,sectorWeb is the updated web by assingning 
                                                            integrals to correspondng sectors, masterInt is the list integrals belong to the sector at 
                                                            currentPosition notInWeb is the list of integrals that are not belong the integral family 
                                                            associated the SectorWeb.
**pickHighestSector(targetInt)**                            return the intgral that belong to the heighest sector, if all integrals belong to the same 
                                                            sector web; otherwise, it returns a list of collection of integrals each need to be handled 
                                                            using different sector webs
**getSortMeasures(l)**                                      return list of sort measures that are used in Laporta Algorithm
**extractCoef(I,ind,l)**                                    return list of values where, the i-th element is the evaluation of coefficient function  at 
                                                            values in the list l of the IBP relation oneIBP, whose index is i=ind[i][1]. Columns of the 
                                                            matrix correspond to the all used indices in the setIBP which are ordered with respect to the 
                                                            output ofgetSortMeasures.
**setMat(S,val)**                                           return matrix,where i-th row correspond to the evaluation of coefficient functions of i-th 
                                                            IBP in setIBP. 
**getRedIBPs(S,p)**                                         list L, L[1]=indIBP, L[2]=seed where, indIBP contain the linearly independent IBP relations 
                                                            of setIBP which are obtained by finite field row reduction over the field Fp. seed contain 
                                                            the indeces correspond to the non-free columns in rref.
**getSortedIntegrals(I)**                                   return list ind where each entry is a pair (indv,sortmeasures), indv is the list of indices
                                                            (seed) appered in the setIBP and sortmeasures is the output of getSortMeasures(indv).The 
                                                            function getSortedIntegrals extract the seeds appeared in the IBP identities of the setIBP, 
                                                            sort them lexicographically based on the values got from getSortMeasures and return the 
                                                            output.
**computeManyIBP(G0,setNu)**                                return setIBP S, where it contains all the IBP relations obtained by module intersection and 
                                                            seeding
**getReducedIBPSystem(G,targetInt )**                       return reduced IBP systerm together with master integrals which are sufficent for reduction 
                                                            of targetInt to master integrals





