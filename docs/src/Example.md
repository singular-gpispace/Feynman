```@meta
CurrentModule=Feynman
```
# Example : fully massless nonplanar double pentagon

To provide an example on how to use our package, we calculate the Baikov matrix of the fully massless nonplanar double pentagon.

We define the graph G from the list of vertices and list of edges. The direction of momenta are taken from the direction  of edges. All external momenta are taken to be outgoing.

```julia
julia> G=simple_graph([1,2,3,4,5,6,7],[(6,1),(6,4),(1,2),(3,7),(4,3),(2,7),(5,6),(7,5),1,2,3,4,5]);
```

We then assign polynomial variables $q_i$ at bounded edges and function field variables $P_i$ at the unbounded edges over a prime filed of characteristic 0.

```julia

julia> G=Feynman.labelGraph(G,0);

julia> printLabeledGraph(G);
printLabeledGraph(G);
Graph with 7 vertices and 8 bounded edges 5 unbounded edges
Edge terms:
["(6, 1)=>q[1]", "(6, 4)=>q[2]", "(1, 2)=>q[3]", "(3, 7)=>q[4]", "(4, 3)=>q[5]", "(2, 7)=>q[6]", "(5, 6)=>q[7]", "(7, 5)=>q[8]", "1=>p[1]", "2=>p[2]", "3=>p[3]", "4=>p[4]", "5=>p[5]"]

```

Then we use balancing condition of the graph (realtions of momenta which are obtained by applying momentum conservation law at each vertex of the graph and to the whole graph) to rewrite each dependent momenta in terms of the eliments in the ordered set $V$ of external momenta and loop momenta. Here we use invlex ordering on $p_1,...,p_E,q_1,...,q_L$ to choose independent external momenta and independent loop momenta. G.elimVars will store the eliminated variables.

```julia
G=eliminateVariables(G);
julia> printLabeledGraph(G);
Graph with 7 vertices and 8 bounded edges 5 unbounded edges
Edge terms:
["(6, 1)=>q[1]", "(6, 4)=>q[2]", "(1, 2)=>-p[1] + q[1]", "(3, 7)=>-p[3] - p[4] + q[2]", "(4, 3)=>-p[4] + q[2]", "(2, 7)=>-p[1] - p[2] + q[1]", "(5, 6)=>q[1] + q[2]", "(7, 5)=>-p[1] - p[2] - p[3] - p[4] + q[1] + q[2]", "1=>p[1]", "2=>p[2]", "3=>p[3]", "4=>p[4]", "5=>-p[1] - p[2] - p[3] - p[4]"]
julia> G.elimvar
7-element Vector{QQMPolyRingElem}:
 p[5]
 q[3]
 q[4]
 q[5]
 q[6]
 q[7]
 q[8]
```
Then the irreducible scalar products associated to G can be printed as follows:

```julia
ISP(G)
Ideal generated by
  p[3]*q[1]
  p[4]*q[1]
  p[1]*q[2]
```

We should remove the eliminated variables from G, in order to compute the Baikov matrix of G.
```julia
julia> G=Feynman.removeElimVars(G);
QQMPolyRingElem[p[1], p[2], p[3], p[4], p[5], q[1], q[2]]
```


We then calculate the Baikov matrix associated to Feynman integral of G. It will also print the assignment of Baikov variables $z_i to each inverse propagators and irreducible scalar products of G.

```julia
julia> G=Feynman.computeBaikovMatrix(G);
labels used for Gram matrix of external loop momenta:
["p[1]*p[2] => 1//2*t[1]"]
["p[1]*p[3] => 1//2*t[2]"]
["p[2]*p[3] => 1//2*t[3]"]
["p[1]*p[4] => 1//2*t[4]"]
["p[2]*p[4] => 1//2*t[5]"]
["p[3]*p[4] => -1//2*t[1] - 1//2*t[2] - 1//2*t[3] - 1//2*t[4] - 1//2*t[5]"]
Assignment of Baikov variables (Z_i) are:
["z[1] => p[3]*q[1]"]
["z[2] => p[4]*q[1]"]
["z[3] => q[1]^2"]
["z[4] => -2*p[1]*q[1] + q[1]^2"]
["z[5] => 2*p[1]*p[2] - 2*p[1]*q[1] - 2*p[2]*q[1] + q[1]^2"]
["z[6] => p[1]*q[2]"]
["z[7] => q[2]^2"]
["z[8] => -2*p[1]*p[2] - 2*p[1]*p[3] - 2*p[1]*p[4] - 2*p[2]*p[3] - 2*p[2]*p[4] - 2*p[3]*q[2] - 2*p[4]*q[2] + q[2]^2"]
["z[9] => -2*p[4]*q[2] + q[2]^2"]
["z[10] => q[1]^2 + 2*q[1]*q[2] + q[2]^2"]
["z[11] => -2*p[1]*q[1] - 2*p[1]*q[2] - 2*p[2]*q[1] - 2*p[2]*q[2] - 2*p[3]*q[1] - 2*p[3]*q[2] - 2*p[4]*q[1] - 2*p[4]*q[2] + q[1]^2 + 2*q[1]*q[2] + q[2]^2"]

julia> G.baikovmatrix
6×6 Matrix{RingElem}:
 0                      …  z[6]
 1//2*t[1]                 1//2*t[2] + 1//2*t[3] + 1//2*t[4] + 1//2*t[5] - z[1] - z[2] - 1//2*z[3] + 1//2*z[5] - z[6] - 1//2*z[7] + 1//2*z[8] + 1//2*z[10] - 1//2*z[11]
 1//2*t[2]                 -1//2*t[1] - 1//2*t[2] - 1//2*t[3] - 1//2*t[4] - 1//2*t[5] - 1//2*z[8] + 1//2*z[9]
 1//2*t[3]                 1//2*z[7] - 1//2*z[9]
 1//2*z[3] - 1//2*z[4]     -1//2*z[3] - 1//2*z[7] + 1//2*z[10]
 z[6]                   …  z[7]
```
