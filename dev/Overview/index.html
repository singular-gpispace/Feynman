<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Overview · Feynman.jl</title><meta name="title" content="Overview · Feynman.jl"/><meta property="og:title" content="Overview · Feynman.jl"/><meta property="twitter:title" content="Overview · Feynman.jl"/><meta name="description" content="Documentation for Feynman.jl."/><meta property="og:description" content="Documentation for Feynman.jl."/><meta property="twitter:description" content="Documentation for Feynman.jl."/><meta property="og:url" content="https://singular-gpispace.github.io/Feynman.jl/Overview/"/><meta property="twitter:url" content="https://singular-gpispace.github.io/Feynman.jl/Overview/"/><link rel="canonical" href="https://singular-gpispace.github.io/Feynman.jl/Overview/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Feynman.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><span class="tocitem">Home</span><ul><li><a class="tocitem" href="../">Feynman</a></li><li><a class="tocitem" href="../Installation/">Installation</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../Example/">Example : Fully massless nonplanar double pentagon</a></li></ul></li><li><span class="tocitem">Functions</span><ul><li class="is-active"><a class="tocitem" href>Overview</a></li></ul></li><li><span class="tocitem">Singular version of Feynman</span><ul><li><a class="tocitem" href="../Installation_sing/">Home</a></li><li><a class="tocitem" href="../Overview_sing/">Overview</a></li><li><a class="tocitem" href="../Example_sing/">Examples</a></li><li><a class="tocitem" href="../Functions_sing/">Functions</a></li><li><a class="tocitem" href="../Functions_custom/">Functions to work with user defined propagators</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Functions</a></li><li class="is-active"><a href>Overview</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Overview</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/singular-gpispace/Feynman" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/singular-gpispace/Feynman/blob/main/docs/src/Overview.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h1><ul><li><a href="#Feynman.Feynman"><code>Feynman.Feynman</code></a></li><li><a href="#Feynman.ISP-Tuple{labeledgraph}"><code>Feynman.ISP</code></a></li><li><a href="#Feynman.balancingIdeal-Tuple{labeledgraph}"><code>Feynman.balancingIdeal</code></a></li><li><a href="#Feynman.computeBaikovMatrix-Tuple{simple_graph}"><code>Feynman.computeBaikovMatrix</code></a></li><li><a href="#Feynman.computeIBP-Tuple{simple_graph, Vector{Int64}, Int64, Bool}"><code>Feynman.computeIBP</code></a></li><li><a href="#Feynman.computeM1-Tuple{labeledgraph}"><code>Feynman.computeM1</code></a></li><li><a href="#Feynman.eliminateVariables-Tuple{labeledgraph}"><code>Feynman.eliminateVariables</code></a></li><li><a href="#Feynman.feynmanDenominators-Tuple{labeledgraph}"><code>Feynman.feynmanDenominators</code></a></li><li><a href="#Feynman.labelGraph-Tuple{simple_graph, Int64}"><code>Feynman.labelGraph</code></a></li><li><a href="#Feynman.makePoly-Tuple{Int64, Int64}"><code>Feynman.makePoly</code></a></li><li><a href="#Feynman.printGraph-Tuple{simple_graph}"><code>Feynman.printGraph</code></a></li><li><a href="#Feynman.printIBP-Tuple{Vector, Int64}"><code>Feynman.printIBP</code></a></li><li><a href="#Feynman.printLabeledGraph-Tuple{labeledgraph}"><code>Feynman.printLabeledGraph</code></a></li><li><a href="#Feynman.propagators-Tuple{labeledgraph}"><code>Feynman.propagators</code></a></li><li><a href="#Feynman.removeElimVars-Tuple{labeledgraph}"><code>Feynman.removeElimVars</code></a></li><li><a href="#Feynman.removeParameter-Tuple{AbstractAlgebra.Ring, Vector}"><code>Feynman.removeParameter</code></a></li><li><a href="#Feynman.removeVariable-Tuple{AbstractAlgebra.Ring, Vector}"><code>Feynman.removeVariable</code></a></li><li><a href="#Feynman.removeVariableLocal-Tuple{AbstractAlgebra.Ring, Vector}"><code>Feynman.removeVariableLocal</code></a></li><li><a href="#Feynman.substituteGraph-Tuple{labeledgraph, AbstractAlgebra.RingElement, AbstractAlgebra.RingElement}"><code>Feynman.substituteGraph</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Feynman.Feynman" href="#Feynman.Feynman"><code>Feynman.Feynman</code></a> — <span class="docstring-category">Module</span></header><section><div><p>The package Feynman generate the Feynman integrand associated to a Feynman diagram (graph) and compute an IBP system using the powerful module-intersection integration-by-parts (IBP) method, suitable for multi-loop and multi-scale Feynman integral reduction. It will provide( soon! ) an application programming interface(API) in OSCAR to use packages NeatIBP, pfd-parallel to make this computation much faster and to solve the reduction problem associated to Feynman integrals completely.The package Feynman is based on the computer algebra system OSCAR and is provided as a package for the Julia programming language. This package can generate the Feynman integrand associated to a Feynman graph <span>$G$</span> if <span>$\text{number of internal edges} &lt; \frac{1}{2}l(l+1)+el$</span>. Here <span>$l$</span> is the loop number and <span>$e=span&lt;p_1,...,p_{n_{ext}}&gt;$</span> is the number of linearly independent external momenta of <span>$G$</span>. In the generic case (That we considered in this package), <span>$e=p_{n_{ext}}-1$</span>. In the case <span>$\text{number of internal edges} &lt; \frac{1}{2}l(l+1)+el$</span>, the package generate the Feynman integrand associated to a larger Feynman graph <span>$G&#39;$</span> so that <span>$G$</span> is a subgraph of  <span>$G&#39;$</span>. User can set appropriately the denomiator powers to zero to obtain the Baikov representation of <span>$G$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/singular-gpispace/Feynman/blob/51787df992bcf140ec7910a59e94ce978cd6a0e7/src/Feynman.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Feynman.ISP-Tuple{labeledgraph}" href="#Feynman.ISP-Tuple{labeledgraph}"><code>Feynman.ISP</code></a> — <span class="docstring-category">Method</span></header><section><div><p>ISP(G::labeledgraph)</p><p><strong>USAGE</strong>   :  ISP(G);</p><p><strong>ASSUME</strong>  : G is a labeled graph.</p><p><strong>RETURN</strong>  : ideal containing the irreducible scalar products(ISPs). </p><p><strong>THEORY</strong>  :  An scalar product that cannot expressed interms of inverse propagators in called an irreducible scalar product</p><p><strong>#Examples</strong></p><pre><code class="language-julia hljs">julia&gt; G=simple_graph([1,2,3,4,5,6],[(1,2),(3,6),(4,5),(1,6),(2,3),(5,6),(3,4),1,2,5,4]);

julia&gt; G=labelGraph(G,0);

julia&gt; Gelim=eliminateVariables(G);

julia&gt; ISP(Gelim)
Ideal generated by
  p[3]*q[1]
  p[1]*q[2]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/singular-gpispace/Feynman/blob/51787df992bcf140ec7910a59e94ce978cd6a0e7/src/Functions.jl#L740-L765">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Feynman.balancingIdeal-Tuple{labeledgraph}" href="#Feynman.balancingIdeal-Tuple{labeledgraph}"><code>Feynman.balancingIdeal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>balancingIdeal(G::labeledgraph)</p><p><strong>USAGE</strong>   : balancingIdeal(G);</p><p><strong>ASSUME</strong>  : G is a labeled graph.</p><p><strong>RETURN</strong>  : Ideal of balancing condition of the graph. i.e Ideal generated by the relation of the momentums which are obtained by applying momentum conservation law to external mementa,         and at each vertex; This is an ideal of the ring G.over.</p><p><strong>#Examples</strong></p><pre><code class="language-julia hljs">julia&gt; G=simple_graph([1,2,3,4],[(1,3),(1,2),(2,4),(3,4),1,2,3,4]);
julia&gt; G=labelGraph(G,0);
julia&gt; balancingIdeal(G)

Ideal generated by
p[1] + p[2] + p[3] + p[4]
p[1] + q[1] + q[2]
p[2] - q[2] + q[3]
p[3] - q[1] + q[4]
p[4] - q[3] - q[4]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/singular-gpispace/Feynman/blob/51787df992bcf140ec7910a59e94ce978cd6a0e7/src/Functions.jl#L223-L247">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Feynman.computeBaikovMatrix-Tuple{simple_graph}" href="#Feynman.computeBaikovMatrix-Tuple{simple_graph}"><code>Feynman.computeBaikovMatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><p>computeBaikovMatrix(G::simple_graphgraph)</p><p><strong>USAGE</strong>   :  computeBaikovMatrix(G);</p><p><strong>ASSUME</strong>  : G is a graph, or G is a labled graph where redundant variables have been eliminated by the procedure eliminateVariables, and deleted from the              ring by the procedure removeElimVars.</p><p><strong>RETURN</strong>  : a labeled graph G, where the computed Baikov matrix and the polynomial ring where baikovmatrix is defined are stored in G.baikovmatrix and G.baikovover respectively.</p><p><strong>THEORY</strong>  :This function compute the Baikov representation of the given graph <span>$G$</span>, which holds the condition <span>$n_{int} \leq N$</span>. There, it will compute the so-called Baikov matrix, which is              the Gram matrix corresponding to the graph such that all scalar products are replaced by the corresponding expression of Baikov variables (<span>$z_1,...,z_N$</span>) and              kinematic variables (<span>$t_i,\,i=1,..., N_B$</span>), assuming <span>$p_i^2=0$</span> for <span>$i=1,...,n_{ext}$</span>. The user only needs to provide the graph details in terms of vertices and edges</p><p>#Examples(If G considerd as labeled graph)</p><pre><code class="language-julia hljs">julia&gt; G=simple_graph([1,2,3,4,5,6],[(6,1),(4,6),(1,2),(3,5),(4,3),(2,5),(5,6),1,2,3,4]);

julia&gt; G=labelGraph(G,0);

julia&gt; G=eliminateVariables(G);

julia&gt; G=removeElimVars(G);

julia&gt; G=computeBaikovMatrix(G);
labels used for Gram matrix of external loop momenta:
[&quot;p[1]*p[2] =&gt; 1//2*t[1]&quot;]
[&quot;p[1]*p[3] =&gt; 1//2*t[2]&quot;]
[&quot;p[2]*p[3] =&gt; -1//2*t[1] - 1//2*t[2]&quot;]
Assignment of Baikov variables (Z_i) are:
[&quot;z[1] =&gt; p[3]*q[1]&quot;]
[&quot;z[2] =&gt; q[1]^2&quot;]
[&quot;z[3] =&gt; -2*p[1]*q[1] + q[1]^2&quot;]
[&quot;z[4] =&gt; 2*p[1]*p[2] - 2*p[1]*q[1] - 2*p[2]*q[1] + q[1]^2&quot;]
[&quot;z[5] =&gt; p[1]*q[2]&quot;]
[&quot;z[6] =&gt; q[2]^2&quot;]
[&quot;z[7] =&gt; 2*p[1]*p[2] - 2*p[1]*q[2] - 2*p[2]*q[2] + q[2]^2&quot;]
[&quot;z[8] =&gt; -2*p[1]*q[2] - 2*p[2]*q[2] - 2*p[3]*q[2] + q[2]^2&quot;]
[&quot;z[9] =&gt; q[1]^2 - 2*q[1]*q[2] + q[2]^2&quot;]

julia&gt; G.baikovmatrix
5×5 Matrix{RingElem}:
 0                      1//2*t[1]                                 …  1//2*z[2] - 1//2*z[3]              z[5]
 1//2*t[1]              0                                            1//2*t[1] + 1//2*z[3] - 1//2*z[4]  1//2*t[1] - z[5] + 1//2*z[6] - 1//2*z[7]
 1//2*t[2]              -1//2*t[1] - 1//2*t[2]                       z[1]                               -1//2*t[1] + 1//2*z[7] - 1//2*z[8]
 1//2*z[2] - 1//2*z[3]  1//2*t[1] + 1//2*z[3] - 1//2*z[4]            z[2]                               1//2*z[2] + 1//2*z[6] - 1//2*z[9]
 z[5]                   1//2*t[1] - z[5] + 1//2*z[6] - 1//2*z[7]     1//2*z[2] + 1//2*z[6] - 1//2*z[9]  z[6]</code></pre><p>#Examples( if G considered as simple graph)</p><pre><code class="language-julia hljs">julia&gt; G=simple_graph([1,2,3,4,5,6],[(6,1),(4,6),(1,2),(3,5),(4,3),(2,5),(5,6),1,2,3,4]);

julia&gt; G=computeBaikovMatrix(G);
labels used for Gram matrix of external loop momenta:
[&quot;p[1]*p[2] =&gt; 1//2*t[1]&quot;]
[&quot;p[1]*p[3] =&gt; 1//2*t[2]&quot;]
[&quot;p[2]*p[3] =&gt; -1//2*t[1] - 1//2*t[2]&quot;]
Assignment of Baikov variables (Z_i) are:
[&quot;z[1] =&gt; p[3]*q[1]&quot;]
[&quot;z[2] =&gt; q[1]^2&quot;]
[&quot;z[3] =&gt; -2*p[1]*q[1] + q[1]^2&quot;]
[&quot;z[4] =&gt; 2*p[1]*p[2] - 2*p[1]*q[1] - 2*p[2]*q[1] + q[1]^2&quot;]
[&quot;z[5] =&gt; p[1]*q[2]&quot;]
[&quot;z[6] =&gt; q[2]^2&quot;]
[&quot;z[7] =&gt; 2*p[1]*p[2] - 2*p[1]*q[2] - 2*p[2]*q[2] + q[2]^2&quot;]
[&quot;z[8] =&gt; -2*p[1]*q[2] - 2*p[2]*q[2] - 2*p[3]*q[2] + q[2]^2&quot;]
[&quot;z[9] =&gt; q[1]^2 - 2*q[1]*q[2] + q[2]^2&quot;]</code></pre><p>G.baikovmatrix is the Gram matrix where entries are replaced with Baikov variables:</p><p class="math-container">\[\begin{bmatrix}
0 &amp; 1//2*t[1] &amp; 1//2*t[2] &amp; 1//2*z[2] - 1//2*z[3] &amp; z[5]\\ 
1//2*t[1] &amp; 0 &amp; -1//2*t[1] - 1//2*t[2] &amp; 1//2*t[1] + 1//2*z[3] - 1//2*z[4] &amp; 1//2*t[1] - z[5] + 1//2*z[6] - 1//2*z[7] \\ 
1//2*t[2] &amp; -1//2*t[1] - 1//2*t[2] &amp; 0 &amp; z[1] &amp; -1//2*t[1] + 1//2*z[7] - 1//2*z[8]\\
1//2*z[2] - 1//2*z[3] &amp; 1//2*t[1] + 1//2*z[3] - 1//2*z[4] &amp; z[1] &amp; z[2] &amp; 1//2*z[2] + 1//2*z[6] - 1//2*z[9]\\
z[5] &amp; 1//2*t[1] - z[5] + 1//2*z[6] - 1//2*z[7] &amp; -1//2*t[1] + 1//2*z[7] - 1//2*z[8] &amp; 1//2*z[2] + 1//2*z[6] - 1//2*z[9] &amp; z[6]\\
\end{bmatrix}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/singular-gpispace/Feynman/blob/51787df992bcf140ec7910a59e94ce978cd6a0e7/src/Functions.jl#L945-L1025">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Feynman.computeIBP-Tuple{simple_graph, Vector{Int64}, Int64, Bool}" href="#Feynman.computeIBP-Tuple{simple_graph, Vector{Int64}, Int64, Bool}"><code>Feynman.computeIBP</code></a> — <span class="docstring-category">Method</span></header><section><div><p>computeIBP(G::simple_graph,Nu::Vector{Int64},cutDeg::Int,showGens::Bool) computeIBP(G::labeledgraph,Nu::Vector{Int64},cutDeg::Int,showGens::Bool) computeIBP(G::labeledgraph,Nu::Vector{Int64},cutDeg::Int)</p><p><strong>USAGE</strong>   :  computeIBP(G,ν,d); </p><p><strong>ASSUME</strong>  : G is a labeled graph, d is a positive integer and ν is vector of integers correspond to the parent diagram of the integral.</p><p><strong>RETURN</strong>  : A set of simplified IBP identities without double propagators (without performing trimming) . </p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; G=simple_graph([1,2,3,4],[(1,4),(1,2),(2,3),(3,4),1,2,3,4]);
julia&gt; set_IBP=computeIBP(G,[1,1,1,0],8,true);
labels used for Gram matrix of external loop momenta:
[&quot;p[1]*p[2] =&gt; 1//2*t[1]&quot;]
[&quot;p[1]*p[3] =&gt; 1//2*t[2]&quot;]
[&quot;p[2]*p[3] =&gt; -1//2*t[1] - 1//2*t[2]&quot;]
Assignment of Baikov variables (Z_i) are:
[&quot;z[1] =&gt; q[1]^2&quot;]
[&quot;z[2] =&gt; 2*p[1]*q[1] + q[1]^2&quot;]
[&quot;z[3] =&gt; 2*p[1]*p[2] + 2*p[1]*q[1] + 2*p[2]*q[1] + q[1]^2&quot;]
[&quot;z[4] =&gt; 2*p[1]*q[1] + 2*p[2]*q[1] + 2*p[3]*q[1] + q[1]^2&quot;]

julia&gt; printIBP(set_IBP.setIBP,3);
First 3 IBP identities associated to G  (Total number of relations=22):
0=(-t[1]^2 - t[1]*t[2] + t[1] + t[2] - D + 6)I(0,-1,-1,0)+(t[1]^2 + t[1]*t[2] + 2)I(0,-1,-2,1)+(t[1]^2 + t[1]*t[2] + 2*t[1] + 2*t[2] + 2)I(0,-2,-1,1)+(t[1]^2 + t[1]*t[2] + D - 6)I(-1,-1,-1,0)+(-2*t[1]^2 - 2*t[1])I(-2,-1,-1,1)+(-t[1]*D + 5*t[1] - t[2]*D + 7*t[2])I(0,-1,-1,1)+(-t[1]*D + 10*t[1] - 8)I(-1,0,-1,1)+(t[1]*D - 6*t[1] + t[2]*D - 6*t[2])I(-1,-1,0,1)+(t[1]*D - 7*t[1] + 8)I(-1,-1,-1,1)+(t[1] + t[2])I(1,-1,-1,0)+(-t[1] - t[2])I(1,-1,-2,1)+(-t[1] - t[2])I(1,-2,-1,1)+(-t[1] + D - 6)I(0,0,-1,0)+(t[1] - 2)I(0,0,-2,1)+(t[1] - t[2] + D - 7)I(0,-1,0,0)+(t[1])I(0,-1,-2,2)+(t[1] + 1)I(0,-1,-2,0)+(-t[1] + t[2] - 1)I(0,-2,0,1)+(t[1] + t[2] - 1)I(0,-2,0,0)+(t[1])I(0,-2,-1,2)+(t[1] - D + 7)I(-1,0,-1,0)+(-2*t[1] + 4)I(-1,0,-2,2)+(-3*t[1] - t[2] - D + 5)I(-1,-1,0,0)+(2*t[1] - 4)I(-1,-1,-2,2)+(-2*t[1])I(-1,-1,-2,1)+(-t[1])I(-1,-1,-2,0)+(2*t[1] + 1)I(-1,-2,0,1)+(-t[1] - t[2])I(-1,-2,0,0)+(2*t[1] + 2*t[2] - 4)I(-1,-2,-1,2)+(-4*t[1] - 4*t[2])I(-1,-2,-1,1)+(-2*t[1] + 4)I(-2,0,-1,2)+(2*t[1])I(-2,0,-1,1)+(t[1])I(-2,0,-1,0)+(2*t[1] + 1)I(-2,-1,0,1)+(-t[1])I(-2,-1,0,0)+(-D + 8)I(0,0,0,0)+(D - 7)I(-1,0,0,0)+(-1)I(1,-1,-2,0)+(1)I(1,-2,0,0)+(-1)I(1,-2,-1,0)+(-1)I(0,-2,1,0)+(1)I(0,-2,-1,0)+(6)I(-1,0,-1,2)+(-2)I(-1,0,-2,3)+(-6)I(-1,-1,-1,2)+(2)I(-1,-1,-2,3)+(1)I(-1,-2,1,0)+(2)I(-1,-2,-1,3)+(-1)I(-2,0,0,1)+(-1)I(-2,0,0,0)+(-2)I(-2,0,-1,3)+(1)I(-2,-1,1,0)+(2)I(-2,-1,-1,3)+(-4)I(-2,-1,-1,2)

0=(-t[1] - 1)I(0,-1,-2,0)+(t[1])I(-1,-1,-2,0)+(t[1] + 1)I(-2,-1,0,0)+(-t[1])I(-2,-1,-1,0)+(1)I(1,-1,-2,0)+(-1)I(1,-2,0,0)+(1)I(1,-2,-1,0)+(-1)I(0,-1,-1,0)+(1)I(0,-2,1,0)+(-1)I(0,-2,-1,0)+(1)I(-1,-1,0,0)+(-1)I(-1,-2,1,0)+(1)I(-1,-2,0,0)+(-1)I(-2,-1,1,0)

0=(-t[1] - t[2])I(0,-2,-1,0)+(t[1] + t[2])I(-1,-2,-1,0)+(-t[1])I(-2,0,-1,0)+(t[1])I(-2,-1,-1,0)+(-1)I(0,0,-1,0)+(1)I(0,0,-2,1)+(1)I(0,-1,-1,0)+(-1)I(0,-1,-2,1)+(1)I(0,-2,0,0)+(-1)I(0,-2,-1,1)+(1)I(-1,0,-1,0)+(-1)I(-1,0,-2,1)+(-1)I(-1,-1,-1,0)+(1)I(-1,-1,-2,1)+(-1)I(-1,-2,0,0)+(1)I(-1,-2,-1,1)+(1)I(-2,0,0,0)+(-1)I(-2,0,-1,1)+(-1)I(-2,-1,0,0)+(1)I(-2,-1,-1,1)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/singular-gpispace/Feynman/blob/51787df992bcf140ec7910a59e94ce978cd6a0e7/src/Functions.jl#L1367-L1401">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Feynman.computeM1-Tuple{labeledgraph}" href="#Feynman.computeM1-Tuple{labeledgraph}"><code>Feynman.computeM1</code></a> — <span class="docstring-category">Method</span></header><section><div><p>computeM1(G::labeledgraph)</p><p><strong>USAGE</strong>   :  computeM1(G); </p><p><strong>ASSUME</strong>  : G is the output of computeBaikovMatrix. </p><p><strong>RETURN</strong>  : It computes the module M1 associated to graph <span>$G$</span> which uses in the powerful module intersection method</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; G=simple_graph([1,2,3,4],[(1,4),(1,2),(2,3),(3,4),1,2,3,4]);
julia&gt; G=computeBaikovMatrix(G);
labels used for Gram matrix of external loop momenta:
[&quot;p[1]*p[2] =&gt; 1//2*t[1]&quot;]
[&quot;p[1]*p[3] =&gt; 1//2*t[2]&quot;]
[&quot;p[2]*p[3] =&gt; -1//2*t[1] - 1//2*t[2]&quot;]
Assignment of Baikov variables (Z_i) are:
[&quot;z[1] =&gt; q[1]^2&quot;]
[&quot;z[2] =&gt; 2*p[1]*q[1] + q[1]^2&quot;]
[&quot;z[3] =&gt; 2*p[1]*p[2] + 2*p[1]*q[1] + 2*p[2]*q[1] + q[1]^2&quot;]
[&quot;z[4] =&gt; 2*p[1]*q[1] + 2*p[2]*q[1] + 2*p[3]*q[1] + q[1]^2&quot;]

julia&gt; computeM1(G)
4-element Vector{Any}:
 QQMPolyRingElem[-z[1] + z[2], -z[1] + z[2], t[1] - z[1] + z[2], t[1] + t[2] - z[1] + z[2], 0]
 QQMPolyRingElem[-t[1] - z[2] + z[3], -z[2] + z[3], -z[2] + z[3], -t[1] - t[2] - z[2] + z[3], 0]
 QQMPolyRingElem[t[1] - z[3] + z[4], t[1] + t[2] - z[3] + z[4], -z[3] + z[4], -z[3] + z[4], 0]
 QQMPolyRingElem[2*z[1], z[1] + z[2], -t[1] + z[1] + z[3], z[1] + z[4], -2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/singular-gpispace/Feynman/blob/51787df992bcf140ec7910a59e94ce978cd6a0e7/src/Functions.jl#L1742-L1772">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Feynman.eliminateVariables-Tuple{labeledgraph}" href="#Feynman.eliminateVariables-Tuple{labeledgraph}"><code>Feynman.eliminateVariables</code></a> — <span class="docstring-category">Method</span></header><section><div><p>eliminateVariables(G::labeledgraph)</p><p><strong>USAGE</strong>   :  eliminateVariables(G);</p><p><strong>ASSUME</strong>  : G is a labeled graph.</p><p><strong>RETURN</strong>  : labeled graph with variables of the bounded edges eliminated according to balancing condition.</p><p>#Examples</p><pre><code class="language-julia hljs">julia&gt; G=simple_graph([1,2,3,4],[(1,3),(1,2),(2,4),(3,4),1,2,3,4]);
julia&gt; G=labelGraph(G,0);
julia&gt; G=eliminateVariables(G);
julia&gt; printLabeledGraph(G);

Graph with 4 vertices and 4 bounded edges 4 unbounded edges
Edge terms:
[&quot;(1, 3)=&gt;q[1]&quot;, &quot;(1, 2)=&gt;-p[1] - q[1]&quot;, &quot;(2, 4)=&gt;-p[1] - p[2] - q[1]&quot;, &quot;(3, 4)=&gt;-p[3] + q[1]&quot;, &quot;1=&gt;p[1]&quot;, &quot;2=&gt;p[2]&quot;, &quot;3=&gt;p[3]&quot;, &quot;4=&gt;-p[1] - p[2] - p[3]&quot;]
julia&gt; G.elimvar

4-element Vector{QQMPolyRingElem}:
 p[4]
 q[2]
 q[3]
 q[4]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/singular-gpispace/Feynman/blob/51787df992bcf140ec7910a59e94ce978cd6a0e7/src/Functions.jl#L313-L340">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Feynman.feynmanDenominators-Tuple{labeledgraph}" href="#Feynman.feynmanDenominators-Tuple{labeledgraph}"><code>Feynman.feynmanDenominators</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>feynmanDenominators(G::labeledgraph)</strong></p><p><strong>USAGE</strong>   :  feynmanDenominators(G);</p><p><strong>ASSUME</strong>  : <span>$G$</span> is a labeled graph with the variables of the bounded edges eliminated according to balancing condition. i.e. <span>$G$</span> is a labeled graph where          the function eliminatedVariables applied.</p><p><strong>RETURN</strong>  : ideal containing the propagators in the Feynman integral</p><p><strong>#Examples</strong></p><pre><code class="language-julia hljs">julia&gt; G=simple_graph([1,2,3,4],[(1,3),(1,2),(2,4),(3,4),1,2,3,4]);
julia&gt; G=labelGraph(G,0);
julia&gt; Gelim=eliminateVariables(G);
julia&gt; feynmanDenominators(Gelim)
Ideal generated by
  q[1]^2
  p[1]^2 + 2*p[1]*q[1] + q[1]^2
  p[1]^2 + 2*p[1]*p[2] + 2*p[1]*q[1] + p[2]^2 + 2*p[2]*q[1] + q[1]^2
  p[3]^2 - 2*p[3]*q[1] + q[1]^2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/singular-gpispace/Feynman/blob/51787df992bcf140ec7910a59e94ce978cd6a0e7/src/Functions.jl#L603-L625">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Feynman.labelGraph-Tuple{simple_graph, Int64}" href="#Feynman.labelGraph-Tuple{simple_graph, Int64}"><code>Feynman.labelGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><p>labelGraph(G::simple_graph,ch::Int)</p><p><strong>USAGE</strong>   : labelGraph(G,ch);</p><p><strong>ASSUME</strong>  : G is a graph and ch is either zero or prime.</p><p><strong>RETURN</strong>  : labeled graph with polynomialvariables qi at the bounded edges and functin filed variables pi at the unbounded edges over a prime filed of characteristic ch Initially we it sets the fields Baikovmatrix and elimvar empty.</p><p><strong>#Examples</strong></p><pre><code class="language-julia hljs">julia&gt; G3=simple_graph([1,2,3,4],[(1,3),(1,2),(2,4),(3,4),1,2,3,4]);
julia&gt; G4=labelGraph(G3,0);
julia&gt; printLabeledGraph(G4);
Graph with 4 vertices and 4 bounded edges 4 unbounded edges
Edge terms:
[&quot;(1, 3)=&gt;q[1]&quot;, &quot;(1, 2)=&gt;q[2]&quot;, &quot;(2, 4)=&gt;q[3]&quot;, &quot;(3, 4)=&gt;q[4]&quot;, &quot;1=&gt;p[1]&quot;, &quot;2=&gt;p[2]&quot;, &quot;3=&gt;p[3]&quot;, &quot;4=&gt;p[4]&quot;]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/singular-gpispace/Feynman/blob/51787df992bcf140ec7910a59e94ce978cd6a0e7/src/Functions.jl#L145-L164">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Feynman.makePoly-Tuple{Int64, Int64}" href="#Feynman.makePoly-Tuple{Int64, Int64}"><code>Feynman.makePoly</code></a> — <span class="docstring-category">Method</span></header><section><div><p>makePoly(n::Int,m::Int)</p><p><strong>USAGE</strong>   :  makePoly(m,n);</p><p><strong>ASSUME</strong>  : m and n are positve integers.</p><p><strong>RETURN</strong>  : A polynomial ring with vatiables t[1],...,t[n],D,z[1],...,z[m] over QQ. </p><p><strong>#Examples</strong></p><pre><code class="language-julia hljs">julia&gt; makePoly(2,3)
Multivariate polynomial ring in 6 variables t[1], t[2], D, z[1], ..., z[3]
  over rational field</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/singular-gpispace/Feynman/blob/51787df992bcf140ec7910a59e94ce978cd6a0e7/src/Functions.jl#L1332-L1347">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Feynman.printGraph-Tuple{simple_graph}" href="#Feynman.printGraph-Tuple{simple_graph}"><code>Feynman.printGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><p>printGraph(G::simple_graph)</p><p><strong>USAGE</strong>   : prinGraph(G);</p><p><strong>ASSUME</strong>  : G is a lsimple graph.</p><p><strong>Theory</strong>: This is the print function used in julia to print a lsimple graph.</p><p><strong>#Examples</strong></p><pre><code class="language-julia hljs">julia&gt; G=Feynman.simple_graph([1,2,3,4],[(1,4),(1,2),(2,3),(3,4),1,2,3,4]);

julia&gt; printGraph(G);
Graph with 4 vertices and 4 bounded edges 4 unbounded edges</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/singular-gpispace/Feynman/blob/51787df992bcf140ec7910a59e94ce978cd6a0e7/src/Functions.jl#L74-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Feynman.printIBP-Tuple{Vector, Int64}" href="#Feynman.printIBP-Tuple{Vector, Int64}"><code>Feynman.printIBP</code></a> — <span class="docstring-category">Method</span></header><section><div><p>printIBP(set_IBP::Vector{Vector{}},n::Int64)</p><p><strong>USAGE</strong>   :  printIBP(set_IBP,n); </p><p><strong>ASSUME</strong>  : set_IBP is the output of computeIBP</p><p><strong>RETURN</strong>  : It prints first n IBP relations </p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; G=simple_graph([1,2,3,4],[(1,4),(1,2),(2,3),(3,4),1,2,3,4]);
julia&gt; set_IBP=computeIBP(G,[1,1,1,0],8,true);
labels used for Gram matrix of external loop momenta:
[&quot;p[1]*p[2] =&gt; 1//2*t[1]&quot;]
[&quot;p[1]*p[3] =&gt; 1//2*t[2]&quot;]
[&quot;p[2]*p[3] =&gt; -1//2*t[1] - 1//2*t[2]&quot;]
Assignment of Baikov variables (Z_i) are:
[&quot;z[1] =&gt; q[1]^2&quot;]
[&quot;z[2] =&gt; 2*p[1]*q[1] + q[1]^2&quot;]
[&quot;z[3] =&gt; 2*p[1]*p[2] + 2*p[1]*q[1] + 2*p[2]*q[1] + q[1]^2&quot;]
[&quot;z[4] =&gt; 2*p[1]*q[1] + 2*p[2]*q[1] + 2*p[3]*q[1] + q[1]^2&quot;]

julia&gt; printIBP(set_IBP.setIBP,3);
First 3 IBP identities associated to G  (Total number of relations=22):
0=(-t[1]^2 - t[1]*t[2] + t[1] + t[2] - D + 6)I(0,-1,-1,0)+(t[1]^2 + t[1]*t[2] + 2)I(0,-1,-2,1)+(t[1]^2 + t[1]*t[2] + 2*t[1] + 2*t[2] + 2)I(0,-2,-1,1)+(t[1]^2 + t[1]*t[2] + D - 6)I(-1,-1,-1,0)+(-2*t[1]^2 - 2*t[1])I(-2,-1,-1,1)+(-t[1]*D + 5*t[1] - t[2]*D + 7*t[2])I(0,-1,-1,1)+(-t[1]*D + 10*t[1] - 8)I(-1,0,-1,1)+(t[1]*D - 6*t[1] + t[2]*D - 6*t[2])I(-1,-1,0,1)+(t[1]*D - 7*t[1] + 8)I(-1,-1,-1,1)+(t[1] + t[2])I(1,-1,-1,0)+(-t[1] - t[2])I(1,-1,-2,1)+(-t[1] - t[2])I(1,-2,-1,1)+(-t[1] + D - 6)I(0,0,-1,0)+(t[1] - 2)I(0,0,-2,1)+(t[1] - t[2] + D - 7)I(0,-1,0,0)+(t[1])I(0,-1,-2,2)+(t[1] + 1)I(0,-1,-2,0)+(-t[1] + t[2] - 1)I(0,-2,0,1)+(t[1] + t[2] - 1)I(0,-2,0,0)+(t[1])I(0,-2,-1,2)+(t[1] - D + 7)I(-1,0,-1,0)+(-2*t[1] + 4)I(-1,0,-2,2)+(-3*t[1] - t[2] - D + 5)I(-1,-1,0,0)+(2*t[1] - 4)I(-1,-1,-2,2)+(-2*t[1])I(-1,-1,-2,1)+(-t[1])I(-1,-1,-2,0)+(2*t[1] + 1)I(-1,-2,0,1)+(-t[1] - t[2])I(-1,-2,0,0)+(2*t[1] + 2*t[2] - 4)I(-1,-2,-1,2)+(-4*t[1] - 4*t[2])I(-1,-2,-1,1)+(-2*t[1] + 4)I(-2,0,-1,2)+(2*t[1])I(-2,0,-1,1)+(t[1])I(-2,0,-1,0)+(2*t[1] + 1)I(-2,-1,0,1)+(-t[1])I(-2,-1,0,0)+(-D + 8)I(0,0,0,0)+(D - 7)I(-1,0,0,0)+(-1)I(1,-1,-2,0)+(1)I(1,-2,0,0)+(-1)I(1,-2,-1,0)+(-1)I(0,-2,1,0)+(1)I(0,-2,-1,0)+(6)I(-1,0,-1,2)+(-2)I(-1,0,-2,3)+(-6)I(-1,-1,-1,2)+(2)I(-1,-1,-2,3)+(1)I(-1,-2,1,0)+(2)I(-1,-2,-1,3)+(-1)I(-2,0,0,1)+(-1)I(-2,0,0,0)+(-2)I(-2,0,-1,3)+(1)I(-2,-1,1,0)+(2)I(-2,-1,-1,3)+(-4)I(-2,-1,-1,2)

0=(-t[1] - 1)I(0,-1,-2,0)+(t[1])I(-1,-1,-2,0)+(t[1] + 1)I(-2,-1,0,0)+(-t[1])I(-2,-1,-1,0)+(1)I(1,-1,-2,0)+(-1)I(1,-2,0,0)+(1)I(1,-2,-1,0)+(-1)I(0,-1,-1,0)+(1)I(0,-2,1,0)+(-1)I(0,-2,-1,0)+(1)I(-1,-1,0,0)+(-1)I(-1,-2,1,0)+(1)I(-1,-2,0,0)+(-1)I(-2,-1,1,0)

0=(-t[1] - t[2])I(0,-2,-1,0)+(t[1] + t[2])I(-1,-2,-1,0)+(-t[1])I(-2,0,-1,0)+(t[1])I(-2,-1,-1,0)+(-1)I(0,0,-1,0)+(1)I(0,0,-2,1)+(1)I(0,-1,-1,0)+(-1)I(0,-1,-2,1)+(1)I(0,-2,0,0)+(-1)I(0,-2,-1,1)+(1)I(-1,0,-1,0)+(-1)I(-1,0,-2,1)+(-1)I(-1,-1,-1,0)+(1)I(-1,-1,-2,1)+(-1)I(-1,-2,0,0)+(1)I(-1,-2,-1,1)+(1)I(-2,0,0,0)+(-1)I(-2,0,-1,1)+(-1)I(-2,-1,0,0)+(1)I(-2,-1,-1,1)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/singular-gpispace/Feynman/blob/51787df992bcf140ec7910a59e94ce978cd6a0e7/src/Functions.jl#L1688-L1720">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Feynman.printLabeledGraph-Tuple{labeledgraph}" href="#Feynman.printLabeledGraph-Tuple{labeledgraph}"><code>Feynman.printLabeledGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><p>printLabeledGraph(G::labeledgraph)</p><p><strong>USAGE</strong>   : printLabeledGraph(G);</p><p><strong>ASSUME</strong>  : G is a labeled graph.</p><p><strong>Theory</strong>: This is the print function used in julia to print a labeled graph.</p><p><strong>#Examples</strong></p><pre><code class="language-julia hljs">julia&gt; var=[&quot;x&quot;,&quot;y&quot;,&quot;z&quot;,&quot;p&quot;,&quot;q&quot;,&quot;r&quot;];
julia&gt; R, (x,y,z,p,q,r)=polynomial_ring(QQ,var);
julia&gt; G=labeledgraph([1,2,3,4],[(1,3),(1,2),(1,2),(2,4),(3,4),(3,4)],R,var,R,[3,4],R,[[y+1,R(2)] [R(3),r+3]]);
julia&gt; printLabeledGraph(G);

Graph with 4 vertices and 6 edges
Edge terms:
[&quot;(1, 3)=&gt;x&quot;, &quot;(1, 2)=&gt;y&quot;, &quot;(1, 2)=&gt;z&quot;, &quot;(2, 4)=&gt;p&quot;, &quot;(3, 4)=&gt;q&quot;, &quot;(3, 4)=&gt;r&quot;]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/singular-gpispace/Feynman/blob/51787df992bcf140ec7910a59e94ce978cd6a0e7/src/Functions.jl#L110-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Feynman.propagators-Tuple{labeledgraph}" href="#Feynman.propagators-Tuple{labeledgraph}"><code>Feynman.propagators</code></a> — <span class="docstring-category">Method</span></header><section><div><p><strong>propagators(G::labeledgraph)</strong></p><p><strong>USAGE</strong>:  propagators(G);</p><p><strong>ASSUME</strong>: G is a labeld graph.</p><p><strong>RETURN</strong>: ideal, containing the denominators in the Feynman integral.</p><p><strong>#Examples</strong></p><pre><code class="language-julia hljs">julia&gt; G=simple_graph([1,2,3,4,5,6],[(6,1),(4,6),(1,2),(3,5),(4,3),(2,5),(5,6),1,2,3,4]);

julia&gt; G=labelGraph(G,0);

julia&gt; Gelim=eliminateVariables(G);

Gelim=removeElimVars(Gelim);

julia&gt; propagators(Gelim)
Ideal generated by
  q[1]^2
  q[2]^2
  -2*p[1]*q[1] + q[1]^2
  2*p[1]*p[2] - 2*p[1]*q[2] - 2*p[2]*q[2] + q[2]^2
  -2*p[1]*q[2] - 2*p[2]*q[2] - 2*p[3]*q[2] + q[2]^2
  2*p[1]*p[2] - 2*p[1]*q[1] - 2*p[2]*q[1] + q[1]^2
  q[1]^2 - 2*q[1]*q[2] + q[2]^2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/singular-gpispace/Feynman/blob/51787df992bcf140ec7910a59e94ce978cd6a0e7/src/Functions.jl#L640-L669">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Feynman.removeElimVars-Tuple{labeledgraph}" href="#Feynman.removeElimVars-Tuple{labeledgraph}"><code>Feynman.removeElimVars</code></a> — <span class="docstring-category">Method</span></header><section><div><p>removeElimVars(G::labeledgraph)</p><p><strong>USAGE</strong>   :  removeElimVars(G);</p><p><strong>ASSUME</strong>  : G is a labled graph.</p><p><strong>RETURN</strong>  : Removes the variables from G.elimvars. This key is generated by the procedure eliminatedVariables.</p><p><strong>#Examples</strong></p><pre><code class="language-julia hljs">julia&gt; G=simple_graph([1,2,3,4,5,6],[(1,2),(3,6),(4,5),(1,6),(2,3),(5,6),(3,4),1,2,5,4]);

julia&gt; G=labelGraph(G,0);

julia&gt; Gelim=eliminateVariables(G);

julia&gt; G=removeElimVars(Gelim);

julia&gt; G.elimvar
Any[]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/singular-gpispace/Feynman/blob/51787df992bcf140ec7910a59e94ce978cd6a0e7/src/Functions.jl#L843-L865">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Feynman.removeParameter-Tuple{AbstractAlgebra.Ring, Vector}" href="#Feynman.removeParameter-Tuple{AbstractAlgebra.Ring, Vector}"><code>Feynman.removeParameter</code></a> — <span class="docstring-category">Method</span></header><section><div><p>removeParameter(P::Ring,l::Vector)</p><p><strong>USAGE</strong>   : removeParameter(R,l);</p><p><strong>ASSUME</strong>  : R is a polynomial ring.</p><p><strong>RETURN</strong>  : polynomial ring with the parameters at indeces in l removed.</p><p>#Examples</p><pre><code class="language-julia hljs">julia&gt; R,v,w=polynomial_ring(QQ,&quot;p&quot;=&gt;(1:5),&quot;q&quot;=&gt;(1:6));
julia&gt; I=ideal(R,[v[1],v[2],v[3],v[4],v[5],w[1]]);
julia&gt; u=complement_of_prime_ideal(I);
julia&gt; S,iso=localization(R,u);
julia&gt; S

julia&gt; S
Localization
  of multivariate polynomial ring in 11 variables p[1], p[2], p[3], p[4], ..., q[6]
    over rational field
  at complement of prime ideal (p[1], p[2], p[3], p[4], p[5], q[1])


  julia&gt; removeParameter(S,[2]) 
Localization
  of multivariate polynomial ring in 10 variables p[1], p[3], p[4], p[5], ..., q[6]
    over rational field
  at complement of prime ideal (p[1], p[3], p[4], p[5], q[1])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/singular-gpispace/Feynman/blob/51787df992bcf140ec7910a59e94ce978cd6a0e7/src/Functions.jl#L526-L556">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Feynman.removeVariable-Tuple{AbstractAlgebra.Ring, Vector}" href="#Feynman.removeVariable-Tuple{AbstractAlgebra.Ring, Vector}"><code>Feynman.removeVariable</code></a> — <span class="docstring-category">Method</span></header><section><div><p>removeVariable(R::Ring,l::Vector)</p><p><strong>USAGE</strong>:  removeVariable(G,l);</p><p><strong>ASSUME</strong>: R is a polynomial ring.</p><p><strong>RERUTN</strong>: polynomial ring with the vaiables at indeces given in l removed.</p><p><strong>#Examples</strong></p><pre><code class="language-julia hljs">julia&gt; R,v=polynomial_ring(QQ,&quot;p&quot;=&gt;(1:3));
julia&gt; removeVariable(R,[2])
Multivariate polynomial ring in 2 variables p[1], p[3]
  over rational field</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/singular-gpispace/Feynman/blob/51787df992bcf140ec7910a59e94ce978cd6a0e7/src/Functions.jl#L415-L431">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Feynman.removeVariableLocal-Tuple{AbstractAlgebra.Ring, Vector}" href="#Feynman.removeVariableLocal-Tuple{AbstractAlgebra.Ring, Vector}"><code>Feynman.removeVariableLocal</code></a> — <span class="docstring-category">Method</span></header><section><div><p>removeVariableLocal(P::Ring,l::Vector)</p><p><strong>USAGE</strong>   : removeVariableLocal(P,l);</p><p><strong>ASSUME</strong>  : P is a local ring locaized by the maximal ideal generated by parameters.</p><p><strong>RETURN</strong>  : local ring where the variables at indeces in l removed. </p><p><strong>#Examples</strong></p><pre><code class="language-julia hljs">ulia&gt; P,p,q=polynomial_ring(QQ,&quot;p&quot;=&gt;(1:4),&quot;q&quot;=&gt;(1:5));

julia&gt; Q=complement_of_prime_ideal(ideal(P,p));

julia&gt; R,iso=localization(P,Q);

julia&gt; removeVariableLocal(R,[1])
Localization
  of multivariate polynomial ring in 8 variables p[2], p[3], p[4], q[1], ..., q[5]
    over rational field
  at complement of prime ideal (p[2], p[3], p[4], q[1])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/singular-gpispace/Feynman/blob/51787df992bcf140ec7910a59e94ce978cd6a0e7/src/Functions.jl#L450-L473">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Feynman.substituteGraph-Tuple{labeledgraph, AbstractAlgebra.RingElement, AbstractAlgebra.RingElement}" href="#Feynman.substituteGraph-Tuple{labeledgraph, AbstractAlgebra.RingElement, AbstractAlgebra.RingElement}"><code>Feynman.substituteGraph</code></a> — <span class="docstring-category">Method</span></header><section><div><p>substituteGraph(G::labeledgraph,a::RingElement,b::RingElement)</p><p><strong>USAGE</strong>   :substituteGraph(G,a,b)</p><p><strong>ASSUME</strong>  : G is a labeled graph</p><p><strong>RETURN</strong>  :a labelled graph with labelling where each &#39;a&#39; is replaced &#39;b&#39;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/singular-gpispace/Feynman/blob/51787df992bcf140ec7910a59e94ce978cd6a0e7/src/Functions.jl#L290-L300">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Example/">« Example : Fully massless nonplanar double pentagon</a><a class="docs-footer-nextpage" href="../Installation_sing/">Home »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Wednesday 5 March 2025 16:27">Wednesday 5 March 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
