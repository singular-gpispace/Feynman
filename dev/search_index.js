var documenterSearchIndex = {"docs":
[{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"CurrentModule = Feynman","category":"page"},{"location":"Functions_sing/#FUNCTIONS","page":"Functions","title":"FUNCTIONS","text":"","category":"section"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"<details>\n<summary>procedure: printMat(matrix M)</summary>\n\n**USAGE**   :  printMat(M); M matrix\n\n**ASSUME**  :  M is a matrix.\n\n**THEORY**  :  This is the print function used by Singular to print a matrix.\n\n**KEYWORDS**: matrix\n\n**Example** :","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular ring R=0,(x),lp; matrix M[2][3]=1,243,3,4,522222,6; printMat(M);","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"<details>\n<summary>procedure: printGraph(graph G)</summary>\n\n**USAGE**   :  printGraph(G); G graph\n\n**ASSUME**  :  G is a graph.\n\n**THEORY**  :  This is the print function used by Singular to print a graph.\n\n**KEYWORDS**:  graph\n\n**Example** :","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular graph G = makeGraph(list(1,2,3,4),list(list(1,3),list(1,2),list(2,4),list(3,4),list(1),list(2),list(3),list(4))); G;","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"<details>\n<summary>procedure: printLabeledGraph(labeledgraph G)</summary>\n\n**USAGE**   :  printLabeledGraph(G); G labeledgraph\n\n**ASSUME**  :  G is a labeled graph.\n\n**THEORY**  :  This is the print function used by Singular to print a labeled graph.\n\n**KEYWORDS**:  Feynman graph\n\n**Example** :","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular ring R=(0),q(1..6),dp; labeledgraph G = makeLabeledGraph(list(1,2,3,4),list(list(1,3),list(1,2),list(1,2),list(2,4),list(3,4),list(3,4)),R, list (q(1),q(2),q(3),q(4),q(5),q(6)),R); G;","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"<details>\n<summary>procedure: printIBP(oneIBP I)</summary>\n\n**USAGE**   :  printIBP(I); I oneIBP\n\n**ASSUME**  :  I is an IBP identity computed using computeIBP.\n\n**THEORY**  :  This is the print function used by Singular to print an IBP relation.\n\n**KEYWORDS**:  Feynman graph\n\n**Example** :","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"<details>\n<summary>procedure: printsetIBP(setIBP I)</summary>\n\n**USAGE**   :  printIBP(I); I setIBP\n\n**ASSUME**  :  I is the set of IBP identities computed using computeIBP.\n\n**THEORY**  :  This is the print function used by Singular to print setIBP.\n\n**KEYWORDS**:  Feynman graph\n\n**Example** :","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"<details>\n<summary>procedure: makeGraph(list v, list e)</summary>\n\n**USAGE**   :  makeGraph(v,e); v list, e list\n\n**ASSUME**  :  v is a list of integers, e is a list of two element lists of v.\n\n**RETURN**  :  graph with vertices v and edges e\n\n**THEORY**  :  Creates a graph from a list of vertices and edges. The vertices can be any   \n                type. The data structure respects the ordering of vertices of edges, so can be used for directed graphs,\n**KEYWORDS**:   graph\n\n**Example** :","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular graph G = makeGraph(list(1,2,3,4),list(list(1,3),list(1,2),list(1,2),list(2,4),list(3,4),list(3,4))); G;","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"<details>\n<summary>procedure: makeLabeledGraph(list v, list e, def R, list lab, def Rpoly)</summary>\n\n**USAGE**   :  makeLabeledGraph(v,e,R,l,P); v list, e list, R ring, l list, P ring \n\n**ASSUME**  :   v is a list of integers, e is a list of two element lists of pairwise \n                different elements of v, R is a ring, l is a list of labels, P is a ring\n\n**RETURN**  :   labeled graph with vertices v and edges e with labels of the edges in R with \n                infinite edges being constants\n\n**THEORY**  :   \n\n**KEYWORDS**:   Feynman graph\n\n**Example** :","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular ring R=(0),q(1..6),dp; labeledgraph G = makeLabeledGraph(list(1,2,3,4),list(list(1,3),list(1,2),list(1,2),list(2,4),list(3,4),list(3,4)),R, list (q(1),q(2),q(3),q(4),q(5),q(6)),R); G;","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"<details>\n<summary>procedure: labelGraph(graph G, int ch)</summary>\n\n**USAGE**   :  labelGraph(G); G graph\n\n**ASSUME**  :  G is a graph and ch is either zero or a prime.\n\n**RETURN**  :  labeled graph with polynomial variables q_i at the bounded edges and function \n                field variables p_i at the unbounded edges over a prime field of \n                characteristic ch\n\n**THEORY**  :  \n\n**KEYWORDS**:   Feynman graph\n\n**Example** :","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular graph G = makeGraph(list(1,2,3,4),list(list(1,3),list(1,2),list(2,4),list(3,4),list(1),list(2),list(3),list(4))); labeledgraph lG = labelGraph(G,0); lG;","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"<details>\n<summary>procedure: balancingIdeal(labeledgraph G)</summary>\n\n**USAGE**   :  balancingIdeal(G); G labeledgraph\n\n**ASSUME**  :   G is a labeled graph\n\n**RETURN**  :  ideal of balancing condition of the graph, basering is assumed to be G.over\n\n**THEORY**  :  \n\n**KEYWORDS**:   Feynman graph\n\n**Example** :","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular graph G = makeGraph(list(1,2,3,4),list(list(1,3),list(1,2),list(2,4),list(3,4),list(1),list(2),list(3),list(4))); labeledgraph lG = labelGraph(G,0); def R= lG.over; setring R; ideal I = balancingIdeal(lG); I;","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"<details>\n<summary>procedure: eliminateVariables(labeledgraph G)</summary>\n\n**USAGE**   :  eliminateVariables(G); G labeledgraph\n\n**ASSUME**  :   G is a labeled graph\n\n**RETURN**  :  labeled graph with variables of the bounded edges eliminated according to \n                balancing condition and using an ordering $q[i]>p[j]$.\n\n**THEORY**  :  \n\n**KEYWORDS**:   Feynman graph\n\n**Example** :","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular graph G = makeGraph(list(1,2,3,4),list(list(1,3),list(1,2),list(2,4),list(3,4),list(1),list(2),list(3),list(4))); labeledgraph lG = labelGraph(G,0); eliminateVariables(lG);","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"<details>\n<summary>procedure: removeVariable(def R, int j)</summary>\n\n**USAGE**   :  removeVariable(R); R ring\n\n**ASSUME**  :   R is a polynomial ring\n\n**RETURN**  :   polynomial ring with j-th variable removed\n\n**THEORY**  :  \n\n**KEYWORDS**:   ring\n\n**Example** :","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular ring R=0,(x,y,z),(lp(2),dp(1)); def S= removeVariable(R,2); S;","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"<details>\n<summary>procedure: removeParameter(def R, int j)</summary>\n\n**USAGE**   :  removeParameter(R); R ring\n\n**ASSUME**  :   R is a polynomial ring\n\n**RETURN**  :  polynomial ring with j-th variable removed\n\n**THEORY**  :  \n\n**KEYWORDS**:   ring\n\n**Example** :","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular ring R=(0,p(1),p(2),p(3)),(x,y,z),(lp(2),dp(1)); def S= removeParameter(R,2); S;","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"<details>\n<summary>procedure: substituteGraph(labeledgraph G, poly a, poly b)</summary>\n\n**USAGE**   :   substituteGraph(G); G labeledgraph\n\n**ASSUME**  :   G is a labeled graph\n\n**RETURN**  :   substitute the variable a in the labeling by b\n\n**THEORY**  :  \n\n**KEYWORDS**:   Feynman graph\n\n**Example** :","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"<details>\n<summary>procedure: feynmanDenominators(labeledgraph G)</summary>\n\n**USAGE**   :  feynmanDenominators(G); G labeledgraph\n\n**ASSUME**  :   G is a labeled graph\n\n**RETURN**  :   ideal containing the propagators in the Feynman integral\n\n**THEORY**  :  \n\n**KEYWORDS**:   Feynman graph\n\n**Example** :","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular graph G = makeGraph(list(1,2,3,4),list(list(1,3),list(1,2),list(2,4),list(3,4),list(1),list(2),list(3),list(4))); labeledgraph lG = labelGraph(G,0); labeledgraph lGelim = eliminateVariables(lG); def R = lGelim.over; setring R; ideal I = feynmanDenominators(lGelim); I;","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"<details>\n<summary>procedure: propagators(labeledgraph G)</summary>\n\n**USAGE**   :   propagators(G); G labeledgraph\n\n**ASSUME**  :   G is a labeled graph\n\n**RETURN**  :   ideal, containing the denominators in the Feynman integral\n\n**THEORY**  :  \n\n**KEYWORDS**:   Feynman graph \n\n**Example** :","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular graph G = makeGraph(list(1,2,3,4),list(list(1,3),list(1,2),list(2,4),list(3,4),list(1),list(2),list(3),list(4))); labeledgraph lG = labelGraph(G,0); labeledgraph lGelim = eliminateVariables(lG); def R = lGelim.over; setring R; ideal I = propagators(lGelim); I;","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"<details>\n<summary>procedure: ISP(labeledgraph G)</summary>\n\n**USAGE**   :  ISP(G); G labeledgraph\n\n**ASSUME**  :   G is a labeled graph\n\n**RETURN**  :  ideal, containing the irreducible scalar products, that is, those scalar \n                product which are not linearly dependent on the propagators.\n\n**THEORY**  :  \n\n**KEYWORDS**:   Feynman graph\n\n**Example** :","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular graph G = makeGraph(list(1,2,3,4,5,6),list(list(1,2),list(3,6),list(4,5),list(1,6),list(2,3),list(5,6),list(3,4),list(1),list(2),list(5),list(4))); labeledgraph lG = labelGraph(G,0); labeledgraph G1 = eliminateVariables(lG); G1; ring R= G1.over; setring R; R; ISP(G1);","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"<details>\n<summary>procedure: removeElimVars(labeledgraph G)</summary>\n\n**USAGE**   :  removeElimVars(G); G labeledgraph\n\n**ASSUME**  :   G is a labeled graph\n\n**RETURN**  :  Removes the variables from G.elimvars. This key is generated by the procedure \n                eliminateVariables.\n\n**THEORY**  :  \n\n**KEYWORDS**:   Feynman graph\n\n**Example** :","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular graph G = makeGraph(list(1,2,3,4,5,6),list(list(1,2),list(3,6),list(4,5),list(1,6),list(2,3),list(5,6),list(3,4),list(1),list(2),list(5),list(4))); labeledgraph lG = labelGraph(G,0); labeledgraph G1 = eliminateVariables(lG); labeledgraph G2 = removeElimVars(G1); G2; ring R= G2.over; setring R; R; G2;","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"<details>\n<summary>procedure: computeBaikovMatrix(def G0)</summary>\n\n**USAGE**   :  computeBaikovMatrix(G); G labeledgraph, or G graph\n\n**ASSUME**  :   G is a Graph, or\n                G is a labeled graph where redundant variables have been eliminated by \n                the procedure eliminateVariables, and deleted from the ring by the \n                procedure removeElimVars.\n\n**RETURN**  :   a labeled graph G1, computes the Baikov matrix of G defined in G1.baikovover \n                and stores it in G1.baikovmatrix\n\n**THEORY**  :  \n\n**KEYWORDS**:   Feynman graph\n\n**Example** :   ","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4))); labeledgraph G1=computeBaikovMatrix(G); ring RB= G1.baikovover; setring RB; RB; matrix B = G1.baikovmatrix; printMat(B);","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"<details>\n<summary>procedure: computeM1(def G0)</summary>\n\n**USAGE**   :  computeM1(G0); G labeledgraph, or G graph\n\n**ASSUME**  :   G is a Graph, or\n                G is a labeled graph where redundant variables have been eliminated by \n                the procedure eliminateVariables, and deleted from the ring by the \n                procedure removeElimVars.\n\n**RETURN**  :   The module M1 over G1.baikovover that requires to compute IBP identities \n\n**THEORY**  :  \n\n**KEYWORDS**:   Feynman graph\n\n**Example** :","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4))); labeledgraph G1=computeBaikovMatrix(G); ring RB=G1.baikovover; RB; module ML=computeM1(G1); ML;","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"<details>\n<summary>procedure: computeM2(def G0,list Nu)</summary>\n\n**USAGE**   :  computeM2(G,Nu); G labeledgraph, or G graph\n\n**ASSUME**  :   G is a Graph, or\n                G is a labeled graph where redundant variables have been eliminated by \n                the procedure eliminateVariables, and deleted from the ring by the \n                procedure removeElimVars.\n                Nu is the seed.\n\n**RETURN**  :   The module M2 over G1.baikovover that requires to compute IBP identities  \n\n**THEORY**  :  \n\n**KEYWORDS**:   Feynman graph\n\n**Example** :","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4))); labeledgraph G1=computeBaikovMatrix(G); ring RB=G1.baikovover; RB; module M2=computeM2(G1,list(1,1,1,0,0,1,0,0,0)); M2; module M2=computeM2(G1, list(1,1,1,1,1,1,1,-5,0)); M2;","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"<details>\n<summary>procedure: computeIBP(def G0,list Nu)</summary>\n\n**USAGE**   :  computeIBP(G0,Nu); G labeledgraph, or G graph\n\n**ASSUME**  :   G is a Graph, or\n                G is a labeled graph where redundant variables have been eliminated by \n                the procedure eliminateVariables, and deleted from the ring by the \n                procedure removeElimVars.\n                Nu is the seed.\n\n**RETURN**  :   The set of IBPS correspond to G0 and given Nu.\n\n**THEORY**  :  \n\n**KEYWORDS**:   Feynman graph\n\n**Example** :\n","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4))); labeledgraph G1=computeBaikovMatrix(G); setIBP S=computeIBP(G1,list(1,1,0,1,0,1,0,1,0)); ring R=S.over; setring R; S; oneIBP I=S.IBP[1]; I;","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"<details>\n<summary>procedure: getSector(list l)</summary>\n\n**USAGE**   :  getSector(l); l list\n\n**ASSUME**  :   l is a list of integer indices of a Feynman integral\n\n**RETURN**  :   list L, L[1]=s The sector (a list of 1s and 0s) that the corresponding      \n                integral belongs L[2]=n The sector in that the integral belongs \n\n**THEORY**  :  \n\n**KEYWORDS**:   Feynman graph\n\n**Example** :","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular list l=list(1,2,-3,-4,0,1); list s=getSector(l); s;","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"<details>\n<summary>procedure: listCombinations(list L,int r)</summary>\n\n**USAGE**   :  listCombintions(L,r); L list, r int\n\n**ASSUME**  :   r is a positive integer such that r < size(L)\n\n**RETURN**  :   list of r-combinations of the elements in the list L\n\n**THEORY**  :  \n\n**KEYWORDS**:   feynman graph\n\n**Example** :","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular ring R=0,(x,y,z),dp; list L=listCombinations(list(1,2,3,4),3); L[1];","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"<details>\n<summary>procedure: generateWebSectors(list seed)</summary>\n\n**USAGE**   :   generateWebSectors(seed);seed list  \n\n**ASSUME**  :   seed is a list of integer values.\n\n**RETURN**  :   Web structure of the sectors L, where L is the list and L[1] is the sector  \n                that correspond to the  given seed and L[i] contain the subsectors of the \n                sectors in L[i-1]. Note that sector maps between the sectors have not been \n                setted. \n\n**THEORY**  :  \n\n**KEYWORDS**:   feynman graph\n\n**Example** :","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular ring R=0,(x,y,z),dp; list l=list(1,-1,0,1,2,-2); list w=generateWebSectors(l);","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"<details>\n<summary>procedure: isSubList(list l1,list l2)</summary>\n\n**USAGE**   :  isSubList(l1,l2); l1 list, l2 list\n\n**ASSUME**  :  l1 and l2 are list of positive integers\n\n**RETURN**  :  1 if elements in l1 contain in l2\n                0 if elements in l1 do not contain in l2\n\n**THEORY**  :  \n\n**KEYWORDS**:   Feynman graph\n\n**Example** :","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular ring R=0,(x,y,z),dp; list l1=list(1,2,3,4,5,6,7); list l2=list(1,4,6); list l3=list(1,2,8); list l4=list(1,4,6); isSubList(l2,l1); isSubList(l3,l1); isSubList(l1,l2); isSubList(l2,l4);","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"<details>\n<summary>procedure: getSectorMap(list L1,list L2)</summary>\n\n**USAGE**   :  getSectorMap(L1,L2); L1 list, L2 list, sector\n\n**ASSUME**  :   L1 and L2 are lists of sectors where the lab field of each sector in both   \n                lists are filled(i.e. two layers of a sector web)\n\n**RETURN**  :   L1 where sectorMap  of each sector in the list L1 is filled.\n\n**THEORY**  :  \n\n**KEYWORDS**:   sector,graph,feynman,setIBP\n\n**Example** :","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular ring R=0,(x,y,z),dp; list l=list(1,-1,0,1,2,-2); list w=generateWebSectors(l); list w1=getSectorMap(w[1],w[2]); w1[1].sectorMap; list w2=getSectorMap(w[2],w[3]); w2[2].sectorMap;","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"<details>\n<summary>procedure: setSectorMap(list sectorWeb)</summary>\n\n**USAGE**   :  setSectorMap(sectorWeb); sectorWeb list, sector\n\n**ASSUME**  :   sectorWeb is an output produced by the function @*generateWebSectors\n\n**RETURN**  :  sectorWeb where the field sectorMap field of each sector in sectorWeb is \n                filled.\n\n**THEORY**  :  \n\n**KEYWORDS**:   sector, generateWebSectors, getSectorMap\n\n**Example** :","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular ring R=0,(x,y,z),dp; list l=list(1,-1,0,1,2,-2); list w=generateWebSectors(l); list w1=setSectorMap(w);","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"<details>\n<summary>procedure: findSector(list sectorWeb, list currentPosition, list L)</summary>\n\n**USAGE**   :  findSector(sectorWeb,currentPosition,L); sectorWeb list,currentPosition list,\n                L list,\n\n**ASSUME**  :   sectorWeb is an output produced by the function generateWebSectors, L is \n                an output produced by the function getSector@\n\n**RETURN**  :   position of the sector in the sectorWeb, where the L belongs. \n                -1, if the sector is not found\n\n**THEORY**  :  \n\n**KEYWORDS**:   sector, generateWebSectors, getSectorMap\n\n**Example** :","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular ring R=0,(x,y,z),dp; list l=list(1,-1,0,1,2,-2); list w=generateWebSectors(l); list w1=setSectorMap(w); list oneInt=list(4,-1,-1,0,-1,-2); list L=getSector(oneInt); def pos=findSector(w1,list(1,1),L[2]); isSubList(w[pos[1]][pos[2]].lab,L[2])==1 && isSubList(L[2],w[pos[1]][pos[2]].lab); //this returns 1, since the given integral is in the sector at pos.","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"//example for a integral that is not in the set list oneInt=list(4,1,0,-1,-2,3); list L=getSector(oneInt); def pos=findSector(w1,list(1,1),L[2]); pos;","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"<details>\n<summary>procedure: updateOneSector(list sectorWeb, list currentPosition,list oneInt)</summary>\n\n**USAGE**   :   updateOneSector(sectorWeb,currentPosition,oneInt); sectorWeb list, sector \n\n**ASSUME**  :   sectorWeb is an output produced by the function generateWebSectors, oneInt \n                is a list of indeces of the denominators associated to an integral \n                correspond to a given feynman graph. Also assume the sectorweb isalso  \n                associated to the same feynman graph.\n\n**RETURN**  :   updated sectorWeb, where the oneInt is assigned to the targetInts field of \n                the seector correspond to provided oneInt\n\n**THEORY**  :  \n\n**KEYWORDS**:   sector, generateWebSectors, getSectorMap,updateWeb,findSector\n\n**Example** :","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular ring R=0,(x,y,z),dp; list l=list(1,-1,0,1,2,-2); list w=generateWebSectors(l); list w1=setSectorMap(w); list oneInt=list(4,-1,-1,0,-1,-2); list w2=updateOneSector(w1,list(1,1),oneInt); list L=getSector(oneInt); L[2]; w2[3][2].lab;","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"<details>\n<summary>procedure: updateWeb(list sectorWeb, list currentPosition,list setInt)</summary>\n\n**USAGE**   :   updateWeb(sectorWeb,currentPosition,setInt); sectorWeb list, sector\n\n**ASSUME**  :   sectorWeb is an output produced by the function generateWebSectors, setInt \n                is a list of indeces of the denominators associated to  integrals correspond \n                to a given feynman graph. Also assume the sectorweb is also  associated to \n                the same feynman graph.\n\n**RETURN**  :   list (sectorWeb,MasterInt,notInWeb) where,\n                sectorWeb is the updated web by assingning integrals to correspondng sectors,\n                masterInt is the list integrals belong to the sector at currentPosition\n                notInWeb is the list of integrals that are not belong the integral family \n                associated the SectorWeb.\n\n**THEORY**  :  \n\n**KEYWORDS**:   generateWebSectors, getSector,findSector\n\n**Example** :\n\n**Example 1:**","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular ring R=(0,(t,D)),(x,y,z),dp; list l=list(1,2,1); list w=generateWebSectors(l); list w1=setSectorMap(w); list setInt=list(list(1,2,3),list(-1,1,2),list(1,1,-1),list(-1,0,-2)); list setInt=list(list(1,2,3)); list setInt=list(l);","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"list L1=pickHighestSector(setInt); list w2=updateWeb(w1,list(1,1),L1[1]); w2[2]; //master integrals w2[3];//integrals not in the web","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"**Example 2:**","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4))); labeledgraph G1=computeBaikovMatrix(G); ring RZ= G1.baikovover; printMat(G1.baikovmatrix);","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"list setInt=list(list(1,1,1,-1,-3,1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1)); list web=generateWebSectors(setInt[1]); list w1=setSectorMap(web);  web=w1; list L1=pickHighestSector(setInt);  ","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"list w2=updateWeb(web,list(1,1),L1[1]); //updateWeb returns a list w3 with w3[1]=sectorWeb,w3[2]=list of master Integrals, w3[3]=list of integrals that not belong to the current web web=w2[1];  setIBP S=computeIBP(G1,L1[1][1]); ring R=S.over; setring R; list L=getRedIBPs(S,101); //L[1]=list of independent IBPs,L[2]=list of master integrals list independIBPs=L[1]; list masterAndTailIntgrals=L[2]; size(independIBPs) < size(S.IBP); //number of linearly independent set of IBPs are less than the number of orginal IBPs. So this returns true","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"oneIBP I1=independIBPs[18];     //Here is an example for one IBP i I1; list w3=updateWeb(web,list(1,1),masterAndTailIntgrals); //updateWeb returns a list w3 with w3[1]=sectorWeb,w3[2]=list of master Integrals, w3[3]=list of integrals that not belong to the current web web=w3[1];    size(web[1][1].targetInts);","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"<details>\n<summary>procedure: getHighestSectorIndex(list targetInt)</summary>\n\n**USAGE**   :   pickHighestSector(targetInt); G is a list of list of integers of same length \n\n**ASSUME**  :   targetInt is the list of target integrals\n\n**RETURN**  :   the intgral that belong to the heighest sector, if all integrals belong to \n                the same sector web; otherwise, it returns a list of collection of integrals \n                each need to be handled using different sector webs,\n\n**THEORY**  :  \n\n**KEYWORDS**:   Feynman graph\n\n**Example** :","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"<details>\n<summary>procedure: pickHighestSector(list targetInt)</summary>\n\n**USAGE**   :   pickHighestSector(targetInt); G is a list of list of integers of same length\n\n**ASSUME**  :   targetInt is the list of target integrals \n\n**RETURN**  :   the intgral that belong to the heighest sector, if all integrals belong to              \n                the same sector web; otherwise, it returns a list of collection of integrals \n                each need to be handled using different sector webs,\n\n**THEORY**  :  \n\n**KEYWORDS**:   Feynman graph\n\n**Example** :","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular setInt=list(list(-1,1,2),list(1,1,-1),list(-1,0,-2),list(1,2,3)); //here we can do the reduction using one web list L=pickHighestSector(setInt); size(L);","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"list setInt=list(list(-1,1,2),list(1,1,-1),list(-1,0,-2)); //here we need more than one web list L=pickHighestSector(setInt); size(L);","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"<details>\n<summary>procedure: getSortMeasures(list l)</summary>\n\n**USAGE**   :  getSortMeasures(l); l list, \n\n**ASSUME**  :   l is a list of integers (i.e a seed). \n\n**RETURN**  :   list of sort measures that are used in Laporta Algorithm\n\n**THEORY**  :  \n\n**KEYWORDS**:   Feynman graph\n\n**Example** :","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular setInt=list(list(-1,1,2),list(1,1,-1),list(-1,0,-2),list(1,2,3));  getSortMeasures(l);","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"<details>\n<summary>procedure: extractCoef(oneIBP I,list ind,list l)</summary>\n\n**USAGE**   :  extractCoef(I,ind,l); I oneIBP,ind list,l list,\n\n**ASSUME**  :   ind is the output of getSortedIntegrals, and l is the list of values over \n                the base field I.baikovover and size(l)=npars(I.baikovover)\n\n**RETURN**  :  list of values where, the i-th element is the evaluation of coefficient \n                function  at values in the list l of the IBP relation oneIBP, whose index is \n                i=ind[i][1].\n\n**THEORY**  :  \n\n**KEYWORDS**:   feynman graph,IBPs\n\n**Example** :","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4))); labeledgraph G1=computeBaikovMatrix(G); setIBP S=computeIBP(G1,list(1,1,0,1,0,1,0,1,0)); ring R=S.over; setring R; list ind = getSortedIntegrals(S); oneIBP I=S.IBP[1]; I; list rowCorrespondToI=extractCoef(I,ind,list(1,2,9)); ","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"// the nonzero coefficient of the IBP relation correspond to integral I(1,1,0,1,0,0,0,1,0). // when we use lex ordering to order the used integrals in set of IBPs, this integral correspond to the 82th place. // so we get only a nonzero value at position 82 and the below, the output will be -14.","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"rowCorrespondToI[82]; //output will be -14","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"<details>\n<summary>procedure: setMat(setIBP S,list val, list ind)</summary>\n\n**USAGE**   :  setMat(S,val); S setIBP,val list\n\n**ASSUME**  :  size(val)=npars(I.baikovover) and val list of integers and  ind is the output \n                of getSortedIntegrals(S)\n\n**RETURN**  :  atrix,where i-th row correspond to the evaluation of coefficient functions of \n                i-th IBP in setIBP. Columns of the matrix correspond to the all used indices \n                in the setIBP which are ordered with respect to the output \n                ofgetSortMeasures. \n\n**THEORY**  :  \n\n**KEYWORDS**:   feynman graph,IBPs\n\n**Example** :\n","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4))); labeledgraph G1=computeBaikovMatrix(G); setIBP S=computeIBP(G1,list(1,1,0,1,0,1,0,1,0)); ring R=S.over; setring R; list ind = getSortedIntegrals(S); matrix N=setMat(S,list(1,2,3),ind);","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"\n<details>\n<summary>procedure: getRedIBPs(setIBP S,int p)</summary>\n\n**USAGE**   :   getRedIBPs(S,p); \n\n**ASSUME**  :   S is setIBP, and p is a prime number. \n\n**RETURN**  :   list L, L[1]=indIBP, L[2]=seed where,\n                indIBP contain the linearly independent IBP relations of setIBP which are \n                obtained by finite field row reduction over the field Fp. \n                seed contain the indeces correspond to the non-free columns in rref.\n\n**THEORY**  :  \n\n**KEYWORDS**:   feynman graph,IBPs\n\n**Example** :","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4))); labeledgraph G1=computeBaikovMatrix(G); setIBP S=computeIBP(G1,list(1,1,0,1,0,1,0,1,0)); ring R=S.over; setring R; list L=getRedIBPs(S,101); size(L[1])<size(S.IBP);","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"<details>\n<summary>procedure: getSortedIntegrals(setIBP I)</summary>\n\n**USAGE**   :  getSortedIntegrals(I); I setIBP,\n\n**ASSUME**  :\n\n**RETURN**  :  list ind where each entry is a pair (indv,sortmeasures),\n                indv is the list of indices(seed) appered in the setIBP \n                and sortmeasures is the output of getSortMeasures(indv).\n                The function getSortedIntegrals extract the seeds appeared in the IBP \n                identities of the setIBP,\n                sort them lexicographically based on the values got from getSortMeasures and \n                return the output.\n\n**THEORY**  :  \n\n**KEYWORDS**: \n\n**Example** :","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4))); labeledgraph G1=computeBaikovMatrix(G); setIBP S=computeIBP(G1,list(1,1,0,1,0,1,0,1,0)); ring R=S.over; setring R; list L=getSortedIntegrals(S); //L list of pair of sorted integrals and the corresponding sorting measures L[1];","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"<details>\n<summary>procedure: computeManyIBP(def G0,list setNu)</summary>\n\n**USAGE**   :  computeManyIBP(G0,setNu); G0 graph,\n\n**ASSUME**  :   setNu is a list of seeds correspond to the graph G0 which are belong to the \n                same sector \n\n**RETURN**  :   setIBP S, where it contains all the IBP relations obtained by module    \n                intersection and seeding \n\n**THEORY**  :  \n\n**KEYWORDS**: \n\n**Example** :","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4))); labeledgraph G1=computeBaikovMatrix(G);","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"//here we compute set of IBPs correspond to two seeds seperately setIBP IBP1=computeIBP(G1,list(1,1,0,1,0,1,0,-1,0)); setIBP IBP2=computeIBP(G1,list(1,1,0,1,0,1,0,-3,0)); size(IBP1.IBP); size(IBP2.IBP);","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"//here we compute set of IBPs correspond both seeds simultaneously  //We can use this only when both integrals belongs to the same sector","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"setIBP S=computeManyIBP(G,list(list(1,1,0,1,0,1,0,-1,0),list(1,1,0,1,0,1,0,-3,0))); size(S.IBP); ","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"<details>\n<summary>procedure: getReducedIBPSystem(graph G,list targetInt )</summary>\n\n**USAGE**   :  getReducedIBPSystem(G,targetInt); targetInt list,G graph,\n\n**ASSUME**  :   G is a graph and targetInt is a list of seeds of target integrals.\n\n**RETURN**  :  ist (reducedIBPs,MI) where  reducedIBPs::setIBP, MI::list.\n                reducedIBPs contain the reduced IBP system for the target integrals\n                MI contain the master integrals\n\n**THEORY**  :  \n\n**KEYWORDS**:   Feynman graph,IBPs\n\n**Example** :","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"singular graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4))); list targetInt=list(list(1,1,1,-1,-3,-1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1)); list finalset=getReducedIBPSystem(G,targetInt); setIBP S=finalset[1]; ring R=S.over; setring R; oneIBP I=S.IBP[5]; I; size(finalset[2]);","category":"page"},{"location":"Functions_sing/","page":"Functions","title":"Functions","text":"</details>","category":"page"},{"location":"Overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"Overview/","page":"Overview","title":"Overview","text":"Modules = [Feynman]","category":"page"},{"location":"Overview/","page":"Overview","title":"Overview","text":"Modules = [Feynman]","category":"page"},{"location":"Overview/#Feynman.Feynman","page":"Overview","title":"Feynman.Feynman","text":"Feynman is a package for computing integration-by-part identities (IBPs) of a Feynman Integral associated to Feynman graph using module intesecation method. \nThis package also provides an interface of Oscar to use the packages NeatIBP developed using Singular and GPI-Space.\n\n\n\n\n\n","category":"module"},{"location":"Overview/#Feynman.ISP-Tuple{labeledgraph}","page":"Overview","title":"Feynman.ISP","text":"ISP(G::labeledgraph)\n\nUSAGE   :  ISP(G);\n\nASSUME  : G is a labeled graph.\n\nRETURN  : idal containing the irreducible scalar products(ISPs), that is, those scalar product which are not linearly dependent on the propagators.\n\n#Examples\n\njulia> G=simple_graph([1,2,3,4,5,6],[(1,2),(3,6),(4,5),(1,6),(2,3),(5,6),(3,4),1,2,5,4]);\n\njulia> G=labelGraph(G,0);\n\njulia> Gelim=eliminateVariables(G);\n\njulia> ISP(Gelim)\nIdeal generated by\n  p[3]*q[1]\n  p[1]*q[2]\n\n\n\n\n\n\n","category":"method"},{"location":"Overview/#Feynman.balancingIdeal-Tuple{labeledgraph}","page":"Overview","title":"Feynman.balancingIdeal","text":"balancingIdeal(G::labeledgraph)\n\nUSAGE   : balancingIdeal(G);\n\nASSUME  : G is a labeled graph.\n\nRETURN  : Ideal of balancing condition of the graph. i.e Ideal generated by the relation of the momentums which are obtained by applying momentum conservation law to external mementa,         and at each vertex; This is an ideal of the ring G.over.\n\n#Examples\n\njulia> G=simple_graph([1,2,3,4],[(1,3),(1,2),(2,4),(3,4),1,2,3,4]);\njulia> G=labelGraph(G,0);\njulia> balancingIdeal(G)\n\nIdeal generated by\np[1] + p[2] + p[3] + p[4]\np[1] + q[1] + q[2]\np[2] - q[2] + q[3]\np[3] - q[1] + q[4]\np[4] - q[3] - q[4]\n\n\n\n\n\n\n","category":"method"},{"location":"Overview/#Feynman.computeBaikovMatrix-Tuple{simple_graph}","page":"Overview","title":"Feynman.computeBaikovMatrix","text":"computeBaikovMatrix(G::simple_graphgraph)\n\nUSAGE   :  computeBaikovMatrix(G);\n\nASSUME  : G is a graph, or G is a labled graph where redundant variables have been eliminated by the procedure eliminateVariables, and deleted from the              ring by the procedure removeElimVars.\n\nRETURN  : a labeled graph G, where the computed Baikov matrix and the polynomial ring where baikovmatrix is defined are stored in G.baikovmatrix and G.baikovover respectively.\n\n#Examples\n\njulia> G=simple_graph([1,2,3,4,5,6,7],[(6,1),(6,4),(1,2),(3,7),(4,3),(2,7),(5,6),(7,5),1,2,3,4,5]);\n\njulia> G=Feynman.labelGraph(G,0);\n\njulia> G=Feynman.eliminateVariables(G);\n\njulia> G=Feynman.removeElimVars(G);\nQQMPolyRingElem[p[1], p[2], p[3], p[4], p[5], q[1], q[2]]\njulia> G=Feynman.computeBaikovMatrix(G);\nlabels used for Gram matrix of external loop momenta:\n[\"p[1]*p[2] => 1//2*t[1]\"]\n[\"p[1]*p[3] => 1//2*t[2]\"]\n[\"p[2]*p[3] => 1//2*t[3]\"]\n[\"p[1]*p[4] => 1//2*t[4]\"]\n[\"p[2]*p[4] => 1//2*t[5]\"]\n[\"p[3]*p[4] => -1//2*t[1] - 1//2*t[2] - 1//2*t[3] - 1//2*t[4] - 1//2*t[5]\"]\nAssignment of Baikov variables (Z_i) are:\n[\"z[1] => p[3]*q[1]\"]\n[\"z[2] => p[4]*q[1]\"]\n[\"z[3] => q[1]^2\"]\n[\"z[4] => -2*p[1]*q[1] + q[1]^2\"]\n[\"z[5] => 2*p[1]*p[2] - 2*p[1]*q[1] - 2*p[2]*q[1] + q[1]^2\"]\n[\"z[6] => p[1]*q[2]\"]\n[\"z[7] => q[2]^2\"]\n[\"z[8] => -2*p[1]*p[2] - 2*p[1]*p[3] - 2*p[1]*p[4] - 2*p[2]*p[3] - 2*p[2]*p[4] - 2*p[3]*q[2] - 2*p[4]*q[2] + q[2]^2\"]\n[\"z[9] => -2*p[4]*q[2] + q[2]^2\"]\n[\"z[10] => q[1]^2 + 2*q[1]*q[2] + q[2]^2\"]\n[\"z[11] => -2*p[1]*q[1] - 2*p[1]*q[2] - 2*p[2]*q[1] - 2*p[2]*q[2] - 2*p[3]*q[1] - 2*p[3]*q[2] - 2*p[4]*q[1] - 2*p[4]*q[2] + q[1]^2 + 2*q[1]*q[2] + q[2]^2\"]\n\njulia> G.baikovmatrix\n6×6 Matrix{RingElem}:\n 0                      …  z[6]\n 1//2*t[1]                 1//2*t[2] + 1//2*t[3] + 1//2*t[4] + 1//2*t[5] - z[1] - z[2] - 1//2*z[3] + 1//2*z[5] - z[6] - 1//2*z[7] + 1//2*z[8] + 1//2*z[10] - 1//2*z[11]\n 1//2*t[2]                 -1//2*t[1] - 1//2*t[2] - 1//2*t[3] - 1//2*t[4] - 1//2*t[5] - 1//2*z[8] + 1//2*z[9]\n 1//2*t[3]                 1//2*z[7] - 1//2*z[9]\n 1//2*z[3] - 1//2*z[4]     -1//2*z[3] - 1//2*z[7] + 1//2*z[10]\n z[6]                   …  z[7]\n\n\n\n\n\n","category":"method"},{"location":"Overview/#Feynman.computeIBP-Tuple{simple_graph, Vector{Int64}, Int64, Bool}","page":"Overview","title":"Feynman.computeIBP","text":"computeIBP(G::labeledgraph,Nu::Vector{Int64},cutDeg::Int)\n\nUSAGE   :  computeIBP(G,ν,d); \n\nASSUME  : G is a labeled graph, d is a positive integer and ν is vector of integers correspond to the parent diagram of the integral.\n\nRETURN  : A set of simplified IBP identities without double propagators (without performing trimming) . \n\n\n\n\n\n","category":"method"},{"location":"Overview/#Feynman.eliminateVariables-Tuple{labeledgraph}","page":"Overview","title":"Feynman.eliminateVariables","text":"eliminateVariables(G::labeledgraph)\n\nUSAGE   :  eliminateVariables(G);\n\nASSUME  : G is a labeled graph.\n\nRETURN  : labeled graph with variables of the bounded edges eliminated according to balancing condition.\n\n#Examples\n\njulia> G=simple_graph([1,2,3,4],[(1,3),(1,2),(2,4),(3,4),1,2,3,4]);\njulia> G=labelGraph(G,0);\njulia> G=eliminateVariables(G);\njulia> printLabeledGraph(G);\n\nGraph with 4 vertices and 4 bounded edges 4 unbounded edges\nEdge terms:\n[\"(1, 3)=>q[1]\", \"(1, 2)=>-p[1] - q[1]\", \"(2, 4)=>-p[1] - p[2] - q[1]\", \"(3, 4)=>-p[3] + q[1]\", \"1=>p[1]\", \"2=>p[2]\", \"3=>p[3]\", \"4=>-p[1] - p[2] - p[3]\"]\njulia> G.elimvar\n\n4-element Vector{QQMPolyRingElem}:\n p[4]\n q[2]\n q[3]\n q[4]\n\n\n\n\n\n","category":"method"},{"location":"Overview/#Feynman.feynmanDenominators-Tuple{labeledgraph}","page":"Overview","title":"Feynman.feynmanDenominators","text":"feynmanDenominators(G::labeledgraph)\n\nUSAGE   :  feynmanDenominators(G);\n\nASSUME  : G is a labeled graph with the variables of the bounded edges eliminated according to balancing condition. i.e. G is a labeled graph where          the function eliminatedVariables applied.\n\nRETURN  : ideal containing the propagators in the Feynman integral\n\n#Examples\n\njulia> G=simple_graph([1,2,3,4],[(1,3),(1,2),(2,4),(3,4),1,2,3,4]);\njulia> G=labelGraph(G,0);\njulia> Gelim=eliminateVariables(G);\njulia> feynmanDenominators(Gelim)\nIdeal generated by\n  q[1]^2\n  p[1]^2 + 2*p[1]*q[1] + q[1]^2\n  p[1]^2 + 2*p[1]*p[2] + 2*p[1]*q[1] + p[2]^2 + 2*p[2]*q[1] + q[1]^2\n  p[3]^2 - 2*p[3]*q[1] + q[1]^2\n\n\n\n\n\n","category":"method"},{"location":"Overview/#Feynman.labelGraph-Tuple{simple_graph, Int64}","page":"Overview","title":"Feynman.labelGraph","text":"labelGraph(G::simple_graph,ch::Int)\n\nUSAGE   : labelGraph(G,ch);\n\nASSUME  : G is a graph and ch is either zero or prime.\n\nRETURN  : labeled graph with polynomialvariables qi at the bounded edges and functin filed variables pi at the unbounded edges over a prime filed of characteristic ch Initially we it sets the fields Baikovmatrix and elimvar empty.\n\n#Examples\n\njulia> G3=Feynman.simple_graph([1,2,3,4],[(1,3),(1,2),(2,4),(3,4),1,2,3,4]);\njulia> G4=Feynman.labelGraph(G3,0);\njulia> Feynman.printLabeledGraph(G4);\nGraph with 4 vertices and 4 bounded edges 4 unbounded edges\nEdge terms:\n[\"(1, 3)=>q[1]\", \"(1, 2)=>q[2]\", \"(2, 4)=>q[3]\", \"(3, 4)=>q[4]\", \"1=>p[1]\", \"2=>p[2]\", \"3=>p[3]\", \"4=>p[4]\"]\n\n\n\n\n\n","category":"method"},{"location":"Overview/#Feynman.makePoly-Tuple{Int64, Int64}","page":"Overview","title":"Feynman.makePoly","text":"makePoly(n::Int,m::Int)\n\nUSAGE   :  makePoly(m,n);\n\nASSUME  : m and n are positve integers.\n\nRETURN  : A polynomial ring with vatiables t[1],...,t[n],z[1],...,z[m] over QQ. \n\n\n\n\n\n","category":"method"},{"location":"Overview/#Feynman.printIBP-Tuple{Vector, Int64}","page":"Overview","title":"Feynman.printIBP","text":"printIBP(set_IBP::Vector{Vector{}},n::Int64)\n\nUSAGE   :  printIBP(set_IBP,n); \n\nASSUME  : set_IBP is the output of computeIBP\n\nRETURN  : It prints first n IBP relations \n\n\n\n\n\n","category":"method"},{"location":"Overview/#Feynman.printLabeledGraph-Tuple{labeledgraph}","page":"Overview","title":"Feynman.printLabeledGraph","text":"printLabeledGraph(G::labeledgraph)\n\nUSAGE   : printLabeledGraph(G);\n\nASSUME  : G is a labeled graph.\n\nTheory: This is the print function used in julia to print a labeled graph.\n\n#Examples\n\njulia> var=[\"x\",\"y\",\"z\",\"p\",\"q\",\"r\"];\njulia> R, (x,y,z,p,q,r)=polynomial_ring(QQ,var);\njulia> G=labeledgraph([1,2,3,4],[(1,3),(1,2),(1,2),(2,4),(3,4),(3,4)],R,var,R,[3,4],R,[[y+1,R(2)] [R(3),r+3]]);\njulia> printLabeledGraph(G);\n\nGraph with 4 vertices and 6 edges\nEdge terms:\n[\"(1, 3)=>x\", \"(1, 2)=>y\", \"(1, 2)=>z\", \"(2, 4)=>p\", \"(3, 4)=>q\", \"(3, 4)=>r\"]\n\n\n\n\n\n\n","category":"method"},{"location":"Overview/#Feynman.propagators-Tuple{labeledgraph}","page":"Overview","title":"Feynman.propagators","text":"propagators(G::labeledgraph)\n\nUSAGE:  propagators(G);\n\nASSUME: G is a labeld graph.\n\nRETURN: ideal, containing the denominators in the Feynman integral.\n\n#Examples\n\njulia> G=simple_graph([1,2,3,4,5,6],[(1,2),(3,6),(4,5),(1,6),(2,3),(5,6),(3,4),1,2,5,4]);\n\njulia> G=labelGraph(G,0);\n\njulia> Gelim=removeElimVars(Gelim);\n\njulia> Gelim=removeElimVars(Gelim);\n\njulia> propagators(Gelim)\nIdeal generated by\n  q[1]^2\n  q[2]^2\n  2*p[1]*p[3] + 2*p[1]*q[1] - 2*p[1]*q[2] + 2*p[3]*q[1] - 2*p[3]*q[2] + q[1]^2 - 2*q[1]*q[2] + q[2]^2\n  2*p[1]*q[1] + q[1]^2\n  -2*p[2]*q[1] + q[1]^2\n  2*p[1]*q[1] - 2*p[1]*q[2] + q[1]^2 - 2*q[1]*q[2] + q[2]^2\n  -2*p[2]*q[1] + 2*p[2]*q[2] + q[1]^2 - 2*q[1]*q[2] + q[2]^2\n\n\n\n\n\n","category":"method"},{"location":"Overview/#Feynman.removeElimVars-Tuple{labeledgraph}","page":"Overview","title":"Feynman.removeElimVars","text":"removeElimVars(G::labeledgraph)\n\nUSAGE   :  removeElimVars(G);\n\nASSUME  : G is a labled graph.\n\nRETURN  : Removes the variables from G.elimvars. This key is generated by the procedure eliminatedVariables.\n\n#Examples\n\njulia> G=simple_graph([1,2,3,4,5,6],[(1,2),(3,6),(4,5),(1,6),(2,3),(5,6),(3,4),1,2,5,4]);\n\njulia> G=labelGraph(G,0);\n\njulia> Gelim=eliminateVariables(G);\n\njulia> G=removeElimVars(Gelim);\nQQMPolyRingElem[p[1], p[2], p[3], p[4], q[1], q[2]]\njulia> G.elimvar\nAny[]\n\n\n\n\n\n","category":"method"},{"location":"Overview/#Feynman.removeParameter-Tuple{AbstractAlgebra.Ring, Vector}","page":"Overview","title":"Feynman.removeParameter","text":"removeParameter(P::Ring,l::Vector)\n\nUSAGE   : removeParameter(R,l);\n\nASSUME  : R is a polynomial ring.\n\nRETURN  : polynomial ring with the parameters at indeces in l removed.\n\n#Examples\n\njulia> R,v,w=polynomial_ring(QQ,\"p\"=>(1:5),\"q\"=>(1:6));\njulia> I=ideal(R,[v[1],v[2],v[3],v[4],v[5],w[1]]);\njulia> u=complement_of_prime_ideal(I);\njulia> S,iso=localization(R,u);\njulia> S\n\njulia> S\nLocalization\n  of multivariate polynomial ring in 11 variables p[1], p[2], p[3], p[4], ..., q[6]\n    over rational field\n  at complement of prime ideal (p[1], p[2], p[3], p[4], p[5], q[1])\n\n\n  julia> removeParameter(S,[2]) \nLocalization\n  of multivariate polynomial ring in 10 variables p[1], p[3], p[4], p[5], ..., q[6]\n    over rational field\n  at complement of prime ideal (p[1], p[3], p[4], p[5], q[1])\n\n\n\n\n\n","category":"method"},{"location":"Overview/#Feynman.removeVariable-Tuple{AbstractAlgebra.Ring, Vector}","page":"Overview","title":"Feynman.removeVariable","text":"removeVariable(R::Ring,l::Vector)\n\nUSAGE:  removeVariable(G,l);\n\nASSUME: R is a polynomial ring.\n\nRERUTN: polynomial ring with the vaiables at indeces given in l removed.\n\n#Examples\n\njulia> R,v=polynomial_ring(QQ,\"p\"=>(1:3));\njulia> Feynman.removeVariable(R,[2])\nMultivariate polynomial ring in 2 variables p[1], p[3]\n  over rational field\n\n\n\n\n\n","category":"method"},{"location":"Overview/#Feynman.removeVariableLocal-Tuple{AbstractAlgebra.Ring, Vector}","page":"Overview","title":"Feynman.removeVariableLocal","text":"removeVariableLocal(P::Ring,l::Vector)\n\nUSAGE   : removeVariableLocal(P,l);\n\nASSUME  : P is a local ring locaized by the maximal ideal generated by parameters.\n\nRETURN  : local ring where the variables at indeces in l removed. \n\n\n\n\n\n","category":"method"},{"location":"Overview/#Feynman.substituteGraph-Tuple{labeledgraph, AbstractAlgebra.RingElement, AbstractAlgebra.RingElement}","page":"Overview","title":"Feynman.substituteGraph","text":"substituteGraph(G::labeledgraph,a::RingElement,b::RingElement)\n\nUSAGE   :substituteGraph(G,a,b)\n\nASSUME  : G is a labeled graph\n\nRETURN  :a labelled graph with labelling where each 'a' is replaced 'b'\n\n\n\n\n\n","category":"method"},{"location":"Example/","page":"Example : Fully massless nonplanar double pentagon","title":"Example : Fully massless nonplanar double pentagon","text":"CurrentModule = Feynman","category":"page"},{"location":"Example/#Example-:-Fully-massless-nonplanar-double-pentagon","page":"Example : Fully massless nonplanar double pentagon","title":"Example : Fully massless nonplanar double pentagon","text":"","category":"section"},{"location":"Example/","page":"Example : Fully massless nonplanar double pentagon","title":"Example : Fully massless nonplanar double pentagon","text":"(Image: alt text)","category":"page"},{"location":"Example/","page":"Example : Fully massless nonplanar double pentagon","title":"Example : Fully massless nonplanar double pentagon","text":"To provide an example on how to use our package, we calculate the Baikov matrix of the fully massless nonplanar double pentagon. ","category":"page"},{"location":"Example/","page":"Example : Fully massless nonplanar double pentagon","title":"Example : Fully massless nonplanar double pentagon","text":"We define the graph G from the list of vertices and list of edges. The direction of momenta are taken from the direction  of edges. All external momenta are taken to be outgoing.","category":"page"},{"location":"Example/","page":"Example : Fully massless nonplanar double pentagon","title":"Example : Fully massless nonplanar double pentagon","text":"julia> G=simple_graph([1,2,3,4,5,6,7],[(6,1),(6,4),(1,2),(3,7),(4,3),(2,7),(5,6),(7,5),1,2,3,4,5]);","category":"page"},{"location":"Example/","page":"Example : Fully massless nonplanar double pentagon","title":"Example : Fully massless nonplanar double pentagon","text":"We then assign polynomial variables qi,  at bounded edges and function field variables pi at the unbounded edges over a prime filed of characteristic 0.","category":"page"},{"location":"Example/","page":"Example : Fully massless nonplanar double pentagon","title":"Example : Fully massless nonplanar double pentagon","text":"\njulia> G=labelGraph(G,0);\n\n\n","category":"page"},{"location":"Example/","page":"Example : Fully massless nonplanar double pentagon","title":"Example : Fully massless nonplanar double pentagon","text":"Then we use balancing condition of the graph (realtions of momenta which are obtained by applying momentum conservation law at each vertex of the graph and to the whole graph) to rewrite each dependent momenta in terms of the eliments in the ordered set V of external momenta and loop momenta. Here we use invlex ordering on p1pEq1qL to choose independent external momenta and independent loop momenta. G.elimVars will store the eliminated variables.","category":"page"},{"location":"Example/","page":"Example : Fully massless nonplanar double pentagon","title":"Example : Fully massless nonplanar double pentagon","text":"julia> G=eliminateVariables(G);\njulia> printLabeledGraph(G);","category":"page"},{"location":"Example/","page":"Example : Fully massless nonplanar double pentagon","title":"Example : Fully massless nonplanar double pentagon","text":"julia> G.elimvar 7-element Vector{QQMPolyRingElem}:  p[5]  q[3]  q[4]  q[5]  q[6]  q[7]  q[8]","category":"page"},{"location":"Example/","page":"Example : Fully massless nonplanar double pentagon","title":"Example : Fully massless nonplanar double pentagon","text":"Then the irreducible scalar products associated to G can be printed as follows:","category":"page"},{"location":"Example/","page":"Example : Fully massless nonplanar double pentagon","title":"Example : Fully massless nonplanar double pentagon","text":"julia>ISP(G)","category":"page"},{"location":"Example/","page":"Example : Fully massless nonplanar double pentagon","title":"Example : Fully massless nonplanar double pentagon","text":"Ideal generated by   p[3]q[1]   p[4]q[1]   p[1]*q[2]","category":"page"},{"location":"Example/","page":"Example : Fully massless nonplanar double pentagon","title":"Example : Fully massless nonplanar double pentagon","text":"\nWe should remove the eliminated variables from $G$, in order to compute the Baikov matrix of $G$.","category":"page"},{"location":"Example/","page":"Example : Fully massless nonplanar double pentagon","title":"Example : Fully massless nonplanar double pentagon","text":"julia julia> G=removeElimVars(G); QQMPolyRingElem[p[1], p[2], p[3], p[4], p[5], q[1], q[2]]","category":"page"},{"location":"Example/","page":"Example : Fully massless nonplanar double pentagon","title":"Example : Fully massless nonplanar double pentagon","text":"\n\nWe then calculate the Baikov matrix associated to Feynman integral of $G$. It will also print the assignment of Baikov variables $z[i]$ to each inverse propagators and irreducible scalar products of $G$.\n","category":"page"},{"location":"Example/","page":"Example : Fully massless nonplanar double pentagon","title":"Example : Fully massless nonplanar double pentagon","text":"julia julia> G=computeBaikovMatrix(G);","category":"page"},{"location":"Example/","page":"Example : Fully massless nonplanar double pentagon","title":"Example : Fully massless nonplanar double pentagon","text":"labels used for Gram matrix of external loop momenta:\n[\"p[1]*p[2] => 1//2*t[1]\"]\n[\"p[1]*p[3] => 1//2*t[2]\"]\n[\"p[2]*p[3] => 1//2*t[3]\"]\n[\"p[1]*p[4] => 1//2*t[4]\"]\n[\"p[2]*p[4] => 1//2*t[5]\"]\n[\"p[3]*p[4] => -1//2*t[1] - 1//2*t[2] - 1//2*t[3] - 1//2*t[4] - 1//2*t[5]\"]\nAssignment of Baikov variables (Z_i) are:\n[\"z[1] => p[3]*q[1]\"]\n[\"z[2] => p[4]*q[1]\"]\n[\"z[3] => q[1]^2\"]\n[\"z[4] => -2*p[1]*q[1] + q[1]^2\"]\n[\"z[5] => 2*p[1]*p[2] - 2*p[1]*q[1] - 2*p[2]*q[1] + q[1]^2\"]\n[\"z[6] => p[1]*q[2]\"]\n[\"z[7] => q[2]^2\"]\n[\"z[8] => -2*p[1]*p[2] - 2*p[1]*p[3] - 2*p[1]*p[4] - 2*p[2]*p[3] - 2*p[2]*p[4] - 2*p[3]*q[2] - 2*p[4]*q[2] + q[2]^2\"]\n[\"z[9] => -2*p[4]*q[2] + q[2]^2\"]\n[\"z[10] => q[1]^2 + 2*q[1]*q[2] + q[2]^2\"]\n[\"z[11] => -2*p[1]*q[1] - 2*p[1]*q[2] - 2*p[2]*q[1] - 2*p[2]*q[2] - 2*p[3]*q[1] - 2*p[3]*q[2] - 2*p[4]*q[1] - 2*p[4]*q[2] + q[1]^2 + 2*q[1]*q[2] + q[2]^2\"]\n\njulia> G.baikovmatrix\n6×6 Matrix{RingElem}:\n 0                      …  z[6]\n 1//2*t[1]                 1//2*t[2] + 1//2*t[3] + 1//2*t[4] + 1//2*t[5] - z[1] - z[2] - 1//2*z[3] + 1//2*z[5] - z[6] - 1//2*z[7] + 1//2*z[8] + 1//2*z[10] - 1//2*z[11]\n 1//2*t[2]                 -1//2*t[1] - 1//2*t[2] - 1//2*t[3] - 1//2*t[4] - 1//2*t[5] - 1//2*z[8] + 1//2*z[9]\n 1//2*t[3]                 1//2*z[7] - 1//2*z[9]\n 1//2*z[3] - 1//2*z[4]     -1//2*z[3] - 1//2*z[7] + 1//2*z[10]\n z[6]                   …  z[7]","category":"page"},{"location":"Example_sing/","page":"Examples","title":"Examples","text":"CurrentModule = Feynman","category":"page"},{"location":"Example_sing/#Example-:-Fully-massless-planar-double-box","page":"Examples","title":"Example : Fully massless planar double box","text":"","category":"section"},{"location":"Example_sing/","page":"Examples","title":"Examples","text":"(Image: alt text) To provide an example of how to use our library, we calculate the set of reduced IBP-system for the target integrals I(111-1-3-1-1-1-1) and I(1-11-1-3-1-1-4-1) correspond to the fully massless planar double box given in figure 6. We assume the compatible Singular version is installed and the library \"feynman.lib\" is downloaded from the git repository provided in chapter one.","category":"page"},{"location":"Example_sing/","page":"Examples","title":"Examples","text":"    LIB \"C:\\\\path_to\\\\Singular_Feynman\\\\feynman.lib\";\n","category":"page"},{"location":"Example_sing/","page":"Examples","title":"Examples","text":"First, the corresponding graph needs to be set. There are 9 Baikov variables in the Baikov representation, which can be seen when computing the Baikov matrix.","category":"page"},{"location":"Example_sing/","page":"Examples","title":"Examples","text":">graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),\nlist(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));\n G;","category":"page"},{"location":"Example_sing/","page":"Examples","title":"Examples","text":"Output:","category":"page"},{"location":"Example_sing/","page":"Examples","title":"Examples","text":"[[6, 1], [4, 6], [1, 2], [3, 5], [4, 3], [2, 5], [5, 6], [1], [2], [3], [4]]\nGraph with 6 vertices, 7 bounded edges and 4 unbounded edges","category":"page"},{"location":"Example_sing/","page":"Examples","title":"Examples","text":"Target integrals need to be set as a list:","category":"page"},{"location":"Example_sing/","page":"Examples","title":"Examples","text":"> list targetInt=list(list(1,1,1,-1,-3,-1,-1,-1,-1),list(1,-1,1,-1,-3,-1,-1,-4,-1));","category":"page"},{"location":"Example_sing/","page":"Examples","title":"Examples","text":"Then, one can call the procedure \\verb|getReducedIBPSystem()| to compute the reduced IBP system and the corresponding master integrals.","category":"page"},{"location":"Example_sing/","page":"Examples","title":"Examples","text":"    list finalset=getReducedIBPSystem(G,targetInt);","category":"page"},{"location":"Example_sing/","page":"Examples","title":"Examples","text":"Provided target integrals belong to the same integral family.","category":"page"},{"location":"Example_sing/","page":"Examples","title":"Examples","text":"It will then show the computational time for each sector computation before returning the output values.\\\nOutput:","category":"page"},{"location":"Example_sing/","page":"Examples","title":"Examples","text":"    Assignment of Baikov variables:\nz(1)=>q(1)^2\nz(2)=>q(2)^2\nz(3)=>q(1)^2-2*p(1)*q(1)\nz(4)=>q(2)^2-2*p(2)*q(2)-2*p(1)*q(2)+2*p(1)*p(2)\nz(5)=>q(2)^2-2*p(3)*q(2)-2*p(2)*q(2)-2*p(1)*q(2)\nz(6)=>q(1)^2-2*p(2)*q(1)-2*p(1)*q(1)+2*p(1)*p(2)\nz(7)=>q(2)^2-2*q(1)*q(2)+q(1)^2\nz(8)=>p(1)*q(2)\nz(9)=>p(3)*q(1)\n------------------------------------------------------------------------------\nStarted the computation in the sector:1 at layer 1.\ntime elapsed for the computation of  module intersection: 0\nElapsed time to set the matrix over Fp in seconds:1\nElapsed time to compute rref in seconds:0. size of the matrix:37 * 57\ncompleted the computation in the sector:1 at layer 1.\n------------------------------------------------------------------------------\nStarted the computation in the sector:1 at layer 2.\ntime elapsed for the computation of  module intersection: 0\nElapsed time to set the matrix over Fp in seconds:1\nElapsed time to compute rref in seconds:0. size of the matrix:35 * 51\ncompleted the computation in the sector:1 at layer 2.\n------------------------------------------------------------------------------\nStarted the computation in the sector:2 at layer 2.\ntime elapsed for the computation of  module intersection: 0\nElapsed time to set the matrix over Fp in seconds:111\nElapsed time to compute rref in seconds:231. size of the matrix:661 * 468\ncompleted the computation in the sector:2 at layer 2.\n------------------------------------------------------------------------------\nStarted the computation in the sector:3 at layer 2.\ntime elapsed for the computation of  module intersection: 0\nElapsed time to set the matrix over Fp in seconds:5\nElapsed time to compute rref in seconds:4. size of the matrix:208 * 96\ncompleted the computation in the sector:3 at layer 2.\n------------------------------------------------------------------------------\nStarted the computation in the sector:1 at layer 3.\ntime elapsed for the computation of  module intersection: 0\nElapsed time to set the matrix over Fp in seconds:112\nElapsed time to compute rref in seconds:230. size of the matrix:743 * 397\ncompleted the computation in the sector:1 at layer 3.\n------------------------------------------------------------------------------\nStarted the computation in the sector:2 at layer 3.\ntime elapsed for the computation of  module intersection: 0\nElapsed time to set the matrix over Fp in seconds:6\nElapsed time to compute rref in seconds:5. size of the matrix:220 * 99\ncompleted the computation in the sector:2 at layer 3.\n------------------------------------------------------------------------------\nStarted the computation in the sector:3 at layer 3.\ntime elapsed for the computation of  module intersection: 0\nElapsed time to set the matrix over Fp in seconds:356\nElapsed time to compute rref in seconds:2645. size of the matrix:3019 * 579\ncompleted the computation in the sector:3 at layer 3.\n>","category":"page"},{"location":"Example_sing/","page":"Examples","title":"Examples","text":"The returned list has two entries; the first is the setIBP containing the reduced IBP system. One can see its size and IBP relations as follows:","category":"page"},{"location":"Example_sing/","page":"Examples","title":"Examples","text":"    > setIBP S=finalset[1];\n    > ring R=S.over;\n    > setring R;","category":"page"},{"location":"Example_sing/","page":"Examples","title":"Examples","text":"    > size(S.IBP);\n    1319","category":"page"},{"location":"Example_sing/","page":"Examples","title":"Examples","text":"There are 1059 independent IBP relations. Before reduction, there were 3019+220+743+208+661+35+37=4923. Since the finite field row reduction is involved, one can verify the result by running the procedure a few times. ","category":"page"},{"location":"Example_sing/","page":"Examples","title":"Examples","text":"     > oneIBP I=S.IBP[5];\n     > I;\n  \n    (2*t(1)*D-20*t(1))I(0,1,1,-1,-3,-1,-1,-2,-1)\n    +(-t(1)*D-12*t(1))I(0,1,1,-1,-4,-1,-1,-1,-1)\n    +(-t(1)*D-8*t(1)-t(2)*D-8*t(2))I(0,1,1,-2,-3,-1,-1,-1,-1)\n    +(-4*t(1))I(0,1,0,-1,-3,-1,-1,-1,-1)+(-2*t(1)*D\n    -6*t(1)+t(2)*D+10*t(2))I(0,0,1,-1,-3,-1,-1,-1,-1)\n    +(-2*t(1)*D-8*t(1))I(-1,1,1,-1,-3,-1,-1,-1,-1)\n    +(-t(1)^2*D-2*t(1)^2-t(1)*t(2)*D-2*t(1)*t(2))I(0,1,1,-1,-3,-1,-1,-1,-1)=0","category":"page"},{"location":"Example_sing/","page":"Examples","title":"Examples","text":"The number of master integrals can be seen as follows:","category":"page"},{"location":"Example_sing/","page":"Examples","title":"Examples","text":"   > size(finalset[2]);\n    1059 ","category":"page"},{"location":"Overview_sing/","page":"Overview","title":"Overview","text":"CurrentModule = Feynman","category":"page"},{"location":"Overview_sing/#OVERVIEW:","page":"Overview","title":"OVERVIEW:","text":"","category":"section"},{"location":"Overview_sing/","page":"Overview","title":"Overview","text":"We generate the Feynman integrand associated to a Feynman diagram and compute reduced IBP system to reduce given target integers to master integrals.","category":"page"},{"location":"Overview_sing/","page":"Overview","title":"Overview","text":"| makeGraph(list, list)                                   | generate a graph from a list of vertices and a list of edges|","category":"page"},{"location":"Overview_sing/","page":"Overview","title":"Overview","text":"|makeLabeledGraph(list, list)                            |generate a labeled graph from a list of vertices and a list of edges|","category":"page"},{"location":"Overview_sing/","page":"Overview","title":"Overview","text":"|printGraph(graph)                                       |print procedure for graphs|","category":"page"},{"location":"Overview_sing/","page":"Overview","title":"Overview","text":"|labelGraph(graph)                                       |label a graph with variables for vertices and edges|","category":"page"},{"location":"Overview_sing/","page":"Overview","title":"Overview","text":"|balancingIdeal(labeledgraph)                            |ideal of balancing conditions|","category":"page"},{"location":"Overview_sing/","page":"Overview","title":"Overview","text":"|eliminateVariables(labeledgraph)                        |eliminate variables according to balancing condition|","category":"page"},{"location":"Overview_sing/","page":"Overview","title":"Overview","text":"|propagators(labeledgraph)         \t                    |generate ideal generated by denominators of the Feynman integral assocated to graph|","category":"page"},{"location":"Overview_sing/","page":"Overview","title":"Overview","text":"|ISP(labeledgraph)\t\t\t                             |     extend the propagators to a basis of the quadratic forms|","category":"page"},{"location":"Overview_sing/","page":"Overview","title":"Overview","text":"|removeElimVars(labeledgraph)                            |Removes the variables from G.elimvars. This key is generated by the procedure| ","category":"page"},{"location":"Overview_sing/","page":"Overview","title":"Overview","text":"|eliminateVariables(labeledgraph)| |","category":"page"},{"location":"Overview_sing/","page":"Overview","title":"Overview","text":"|computeBaikovMatrix(graph)                              |computes the Baikov matrix of G defined in G1.baikovover and stores it in G1.baikovmatrix|","category":"page"},{"location":"Overview_sing/","page":"Overview","title":"Overview","text":"|computeM1(labeledgraph)                                 |generate the module M1 over G1.baikovover that requires to compute IBP identities |","category":"page"},{"location":"Overview_sing/","page":"Overview","title":"Overview","text":"|computeM2(labeledgraph,list)                            |generate the module M2 over G1.baikovover that requires to compute IBP identities| ","category":"page"},{"location":"Overview_sing/","page":"Overview","title":"Overview","text":"|computeIBP(labeledgraph,list)                           |generate the set of IBPS correspond to the given indices of denominators of the feynman  |                                                            integral.|","category":"page"},{"location":"Overview_sing/","page":"Overview","title":"Overview","text":"|getSector(list)                                         |returns the sector (a list of 1s and 0s) that the integral belongs|","category":"page"},{"location":"Overview_sing/","page":"Overview","title":"Overview","text":"|listCombintions(list,int)                               |returns the list of r-combinations of the elements in the list L|","category":"page"},{"location":"Overview_sing/","page":"Overview","title":"Overview","text":"|generateWebSectors(list)                                |generate the Web structure of the sectors L, where L is the list and L[1] is the sector  that correspond to the seed and L[i]  contain the subsectors of the sectors in L[i-1]. Note that sector maps between the sectors have not been setted.|","category":"page"},{"location":"Overview_sing/","page":"Overview","title":"Overview","text":"|isSubList(l1,l2)                                        |return 1 if elements in l1 contain in l2  0 if elements in l1 do not contain in l2|","category":"page"},{"location":"Overview_sing/","page":"Overview","title":"Overview","text":"|getSectorMap(L1,L2)                                     |L1 where sectorMap  of each sector in the list L1 is filled.|","category":"page"},{"location":"Overview_sing/","page":"Overview","title":"Overview","text":"|setSectorMap(sectorWeb)                                 |sectorWeb where the field sectorMap field of each sector in sectorWeb is filled.|","category":"page"},{"location":"Overview_sing/","page":"Overview","title":"Overview","text":"|findSector(sectorWeb,currentPosition,L)                 |return position of the sector in the sectorWeb, where the L belongs. return -1, if the  sector is not found|","category":"page"},{"location":"Overview_sing/","page":"Overview","title":"Overview","text":"|updateOneSector(sectorWeb,currentPosition,oneInt)       |updated sectorWeb, where the oneInt is assigned to the targetInts field of the seector correspond to provided oneInt|","category":"page"},{"location":"Overview_sing/","page":"Overview","title":"Overview","text":"|updateWeb(sectorWeb,currentPosition,setInt)             |return a list(sectorWeb,MasterInt,notInWeb) where,sectorWeb is the updated web by assingning integrals to correspondng sectors, masterInt is the list integrals belong to the sector at currentPosition notInWeb is the list of integrals that are not belong the integral family associated the SectorWeb.|","category":"page"},{"location":"Overview_sing/","page":"Overview","title":"Overview","text":"|pickHighestSector(targetInt)                            |return the intgral that belong to the heighest sector, if all integrals belong to the same sector web; otherwise, it returns a list of collection of integrals each need to be handled using different sector webs|","category":"page"},{"location":"Overview_sing/","page":"Overview","title":"Overview","text":"|getSortMeasures(l)                                      |return list of sort measures that are used in Laporta Algorithm|","category":"page"},{"location":"Overview_sing/","page":"Overview","title":"Overview","text":"|extractCoef(I,ind,l)                                    |return list of values where, the i-th element is the evaluation of coefficient function  at values in the list l of the IBP relation oneIBP, whose index is i=ind[i][1]. Columns of the matrix correspond to the all used indices in the setIBP which are ordered with respect to the output ofgetSortMeasures.|","category":"page"},{"location":"Overview_sing/","page":"Overview","title":"Overview","text":"|setMat(S,val)                                           |return matrix,where i-th row correspond to the evaluation of coefficient functions of i-th IBP in setIBP.| ","category":"page"},{"location":"Overview_sing/","page":"Overview","title":"Overview","text":"|getRedIBPs(S,p)                                         |list L, L[1]=indIBP, L[2]=seed where, indIBP contain the linearly independent IBP relations of setIBP which are obtained by finite field row reduction over the field Fp. seed contain the indeces correspond to the non-free columns in rref.|","category":"page"},{"location":"Overview_sing/","page":"Overview","title":"Overview","text":"|getSortedIntegrals(I)|return list ind where each entry is a pair (indv,sortmeasures), indv is the list of indices(seed) appered in the setIBP and sortmeasures is the output of getSortMeasures(indv).The function getSortedIntegrals extract the seeds appeared in the IBP identities of the setIBP, sort them lexicographically based on the values got from getSortMeasures and return the output.|","category":"page"},{"location":"Overview_sing/","page":"Overview","title":"Overview","text":"|computeManyIBP(G0,setNu)  | return setIBP S, where it contains all the IBP relations obtained by module intersection and seeding|","category":"page"},{"location":"Overview_sing/","page":"Overview","title":"Overview","text":"|getReducedIBPSystem(G,targetInt )| return reduced IBP systerm together with master integrals which are sufficent for reduction of targetInt to master integrals|","category":"page"},{"location":"Installation_sing/","page":"Home","title":"Home","text":"CurrentModule = Feynman","category":"page"},{"location":"Installation_sing/#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"Installation_sing/","page":"Home","title":"Home","text":"We assume that SINGULAR is installed in a recent stable version (4.1.1 Feb 2018  or 4.3.2.0 Jan_2022 ) .","category":"page"},{"location":"Installation_sing/","page":"Home","title":"Home","text":"Run Singular in the terminal,","category":"page"},{"location":"Installation_sing/","page":"Home","title":"Home","text":" >Singular\n                     SINGULAR                                 /  Development\n A Computer Algebra System for Polynomial Computations       /   version 4.1.1\n                                                           0<\n by: W. Decker, G.-M. Greuel, G. Pfister, H. Schoenemann     \\   Feb 2018\nFB Mathematik der Universitaet, D-67653 Kaiserslautern        \\  Debian 1:4.1.1-p2+ds-4build2\n> ","category":"page"},{"location":"Installation_sing/","page":"Home","title":"Home","text":"Then install the library feynman.lib.","category":"page"},{"location":"Installation_sing/","page":"Home","title":"Home","text":"> LIB \"/path_to/Singular_Feynman/feynman.lib\";\n// ** redefining setMat (LIB \"/path_to/Feynman/Singular_Feynman/feynman.lib\";)\n// ** redefining setMat (LIB \"/path_to/Feynman/Singular_Feynman/feynman.lib\";)\n// ** loaded /path_to/Feynman/Singular_Feynman/feynman.lib (4.3.2.0,Jan_2022)\n// ** loaded /usr/bin/../share/singular/LIB/general.lib (4.1.1.0,Dec_2017)\n// ** loaded /usr/bin/../share/singular/LIB/matrix.lib (4.1.1.0,Dec_2017)\n// ** loaded /usr/bin/../share/singular/LIB/nctools.lib (4.1.1.0,Dec_2017)\n// ** loaded /usr/bin/../share/singular/LIB/random.lib (4.1.1.0,Dec_2017)\n// ** loaded /usr/bin/../share/singular/LIB/ring.lib (4.1.1.0,Dec_2017)\n// ** loaded /usr/bin/../share/singular/LIB/primdec.lib (4.1.1.0,Dec_2017)\n// ** loaded /usr/bin/../share/singular/LIB/absfact.lib (4.1.1.0,Dec_2017)\n// ** loaded /usr/bin/../share/singular/LIB/triang.lib (4.1.1.0,Dec_2017)\n// ** loaded /usr/bin/../share/singular/LIB/elim.lib (4.1.1.0,Dec_2017)\n// ** loaded /usr/bin/../share/singular/LIB/poly.lib (4.1.1.0,Dec_2017)\n// ** loaded /usr/bin/../share/singular/LIB/inout.lib (4.1.1.0,Dec_2017)\n// ** loaded /usr/bin/../share/singular/LIB/linalg.lib (4.1.1.0,Dec_2017)\n> ","category":"page"},{"location":"#Feynman","page":"Feynman","title":"Feynman","text":"","category":"section"},{"location":"","page":"Feynman","title":"Feynman","text":"Documentation for Feynman.","category":"page"},{"location":"","page":"Feynman","title":"Feynman","text":"The package Feynman computes complete set of IBP identities of the Feynman integral associated to a given Feynman graph using the powerful module-intersection integration-by-parts (IBP) method, suitable for multi-loop and multi-scale Feynman integral reduction. It will provide an application programming interface(API) in OSCAR to use packages NeatIBP, pfd-parallel to make this computation much faster.The package Feynman is based on the computer algebra system OSCAR and is provided as a package for the Julia programming language.","category":"page"},{"location":"","page":"Feynman","title":"Feynman","text":"Installation\nExample\nOverview","category":"page"},{"location":"Installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"Installation/","page":"Installation","title":"Installation","text":"We assume that Julia is installed in a recent enough version to run OSCAR. Navigate in a terminal to the folder where you want to install the package and pull the package from Github:","category":"page"},{"location":"Installation/","page":"Installation","title":"Installation","text":"git pull https://github.com/singular-gpispace/Feynman.git","category":"page"},{"location":"Installation/","page":"Installation","title":"Installation","text":"In the same folder execute the following command:","category":"page"},{"location":"Installation/","page":"Installation","title":"Installation","text":"julia --project","category":"page"},{"location":"Installation/","page":"Installation","title":"Installation","text":"This will activate the environment for our package. In Julia install missing packages:","category":"page"},{"location":"Installation/","page":"Installation","title":"Installation","text":"import Pkg; Pkg.instantiate()","category":"page"},{"location":"Installation/","page":"Installation","title":"Installation","text":"and load our package. On the first run this may take some time.","category":"page"},{"location":"Installation/","page":"Installation","title":"Installation","text":"using Feynman  ","category":"page"}]
}
