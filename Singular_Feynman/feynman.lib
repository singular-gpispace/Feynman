//////////////////////////////////////////////////////////////////////////////
version="version classify2.lib 4.0.0.0 Jun_2013 "; // $Id:  $
category="Commutative Algebra";
info="
LIBRARY: feynman.lib   Feynman integrals and IBP

OVERVIEW:
We generate the Feynman integrand associated to a Feynman diagram.

KEYWORDS:
Feynman integral;

PROCEDURES:
makeGraph(list, list)                     generate a graph from a list of vertices and a list of edges
makeLabeledGraph(list, list)              generate a labeled graph from a list of vertices and a list of edges
printGraph(graph)                         print procedure for graphs
labelGraph(graph)                         label a graph with variables for vertices and edges
balancingIdeal(labeledgraph)              ideal of balancing conditions
eliminateVariables(labeledgraph)          eliminate variables according to balancing condition
propagators(labeledgraph)         	  generate ideal generated by denominators of the Feynman integral assocated to graph
ISP(labeledgraph)			  extend the propagators to a basis of the quadratic forms

";

LIB "linalg.lib";
proc mod_init()
{
LIB "general.lib";
newstruct("graph","list vertices, list edges");
newstruct("labeledgraph","list vertices, list edges, ring over, list labels, ring overpoly, list elimvars, ring baikovover, matrix baikovmatrix");
newstruct("Net","list rows");
newstruct("oneIBP","list c, list i");
newstruct("setIBP","ring over,list seed,list IBP");
system("install","labeledgraph","print",printLabeledGraph,1);
system("install","graph","print",printGraph,1);
system("install","oneIBP","print",printIBP,1);
system("install","setIBP","print",printsetIBP,1);
system("install","Net","print",printNet,1);
system("install","Net","+",catNet,2);
option(noredefine);
}



static proc catNet(Net N, Net M)
{
list L;
list LN=N.rows;
list LM=M.rows;
int widthN=size(LN[1]);
int widthM=size(LM[1]);
int nm=max(size(LN),size(LM));
for (int j=1; j<=nm; j++)
{
    if (j>size(LN)){LN[j]=emptyString(widthN);}
    if (j>size(LM)){LM[j]=emptyString(widthM);}
    L[j]=LN[j]+LM[j];
}
Net NM;
NM.rows=L;
return(NM);}


static proc netList(list L1)
{
  Net N=net("[");
  for (int j=1; j<=size(L1)-1; j++)
  {
     N=N+net(L1[j])+net(", ");
  }
  N=N+net(L1[size(L1)])+net("]");
  return(N);
}

static proc printNet(Net N)
{
list L = N.rows;
for (int j=1; j<=size(L); j++)
{
   print(L[j]);
}
}

static proc net(def M){
  if (typeof(M)=="Net"){
    return(M);
  }
  if (typeof(M)=="list"){
    return(netList(M));
  }
  Net N;
  list L;
  L[1]=string(M);
  N.rows=L;
return(N);}



proc printGraph(graph G)
"USAGE:  printGraph(G); G graph@*
ASSUME:  G is a graph.
THEORY:  This is the print function used by Singular to print a graph.
KEYWORDS: graph
EXAMPLE:  example printGraph; shows an example
"
{
  print(netList(G.edges));
  int ct = 0;
  for (int i =1 ; i<=size(G.edges); i++){if (size((G.edges)[i])==1){ct=ct+1;}}
  if (ct!=0)
  {
      print("Graph with "+string(size(G.vertices))+" vertices, "+string(size(G.edges)-ct)+" bounded edges and "+string(ct)+" unbounded edges");
  } else {
      print("Graph with "+string(size(G.vertices))+" vertices and "+string(size(G.edges))+" edges");
  }
}
example
{ "EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4),list(list(1,3),list(1,2),list(2,4),list(3,4),list(1),list(2),list(3),list(4)));
  G;
}


proc printLabeledGraph(labeledgraph G)
"USAGE:  printLabeledGraph(G); G labeledgraph@*
ASSUME:  G is a labeled graph.
THEORY:  This is the print function used by Singular to print a labeled graph.
KEYWORDS: Feynman graph
EXAMPLE:  example printLabeledGraph; shows an example
"
{
  print(netList(G.edges));
  int ct;
  for (int i =1 ; i<=size(G.edges); i++){if (size((G.edges)[i])==1){ct=ct+1;}}
  if (ct!=0)
  {
      print("Graph with "+string(size(G.vertices))+" vertices, "+string(size(G.edges)-ct)+" bounded edges and "+string(ct)+" unbounded edges");
  } else {
      print("Graph with "+string(size(G.vertices))+" vertices and "+string(size(G.edges))+" edges");
  }
  int ringdef = (typeof(basering)=="ring");
  if (ringdef){def R1 = basering;}
  def R2 = G.over;
  setring R2;
  list labels =G.labels;
  "";
  print("Edgeterms: ");
  list ev;
  Net ne;
  for (i = 1; i<=size(G.edges);i++){
     ne = net(G.edges[i])+net(" => ")+net(string(labels[i]));
     ev[i]=ne;
  }
  print(netList(ev));
  kill labels;
  if (ringdef){setring R1;}

}
example
{ "EXAMPLE:"; echo=2;
  ring R=(0),q(1..6),dp;
  labeledgraph G = makeLabeledGraph(list(1,2,3,4),list(list(1,3),list(1,2),list(1,2),list(2,4),list(3,4),list(3,4)),R, list (q(1),q(2),q(3),q(4),q(5),q(6)),R);
  G;
}

proc printIBP(oneIBP I)
"USAGE:  printIBP(I); I oneIBP@*
ASSUME:  I is an IBP identity computed using computeIBP.
THEORY:  This is the print function used by Singular to print an IBP relation.
KEYWORDS: Feynman graph
EXAMPLE:  example printLabeledGraph; shows an example
"
{
Net ne;
ne = net(string(I.c[1]))+net("I")+net("(")+net(string(I.i[1]))+net(")");
  for (int j = 2; j<=size(I.c);j++){
     ne = ne+net("+")+net(string(I.c[j]))+net("I")+net("(")+net(string(I.i[j]))+net(")");
     
  }
  ne=ne+net("=0");
printNet(ne);
}

proc printsetIBP(setIBP I)
"USAGE:  printIBP(I); I setIBP@*
ASSUME:  I is the set of IBP identities computed using computeIBP.
THEORY:  This is the print function used by Singular to print setIBP.
KEYWORDS: Feynman graph
EXAMPLE:  example printLabeledGraph; shows an example
"
{
print("Collection of IBP identities of the given graph with respect to the seed "+string(I.seed)+".");
print("Total number of identities= "+string(size(I.IBP)));
}


proc makeGraph(list v, list e)
"USAGE:  makeGraph(v,e); v list, e list@*
ASSUME:  v is a list of integers, e is a list of two element lists of v.
RETURN:  graph with vertices v and edges e
THEORY:  Creates a graph from a list of vertices and edges. The vertices can be any type. The data structure 
         respects the ordering of vertices of edges, so can be used for directed graphs,
KEYWORDS: graph
EXAMPLE:  example makeGraph; shows an example
"
{
  graph G;
  G.vertices = v;
  G.edges = e;
  return(G);
}
example
{ "EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4),list(list(1,3),list(1,2),list(1,2),list(2,4),list(3,4),list(3,4)));
  G;
}

proc makeLabeledGraph(list v, list e, def R, list lab, def Rpoly)
"USAGE:  makeLabeledGraph(v,e,R,l,P); v list, e list, R ring, l list, P ring @*
ASSUME:  v is a list of integers, e is a list of two element lists of pairwise different elements of v, R is a ring, l is a list of labels, P is a ring
RETURN:  labeled graph with vertices v and edges e with labels of the edges in R with infinite edges being constants
KEYWORDS: Feynman graph
EXAMPLE:  example makeLabeledGraph; shows an example
"
{
  labeledgraph G;
  G.vertices = v;
  G.edges = e;
  G.over = R;
  G.overpoly = Rpoly;
  G.labels = lab;
  return(G);
}
example
{ "EXAMPLE:"; echo=2;
  ring R=(0),q(1..6),dp;
  labeledgraph G = makeLabeledGraph(list(1,2,3,4),list(list(1,3),list(1,2),list(1,2),list(2,4),list(3,4),list(3,4)),R, list (q(1),q(2),q(3),q(4),q(5),q(6)),R);
  G;
}



proc labelGraph(graph G, int ch)
"USAGE:  labelGraph(G); G graph@*
ASSUME:  G is a graph and ch is either zero or a prime.
RETURN:  labeled graph with polynomial variables q_i at the bounded edges and function field variables p_i at the unbounded edges over a prime field of characteristic ch
KEYWORDS: Feynman graph
EXAMPLE:  example labelGraph; shows an example
"
{
  int ringdef = (typeof(basering)=="ring");
  if (ringdef){def R1 = basering;}
  int ct;
  for (int i = 1 ; i<=size(G.edges); i++){if (size((G.edges)[i])==1){ct=ct+1;}}
  int anzq = size(G.edges)-ct;
  ring P = (ch),(p(1..ct),q(1..anzq)),rp;
  ring R = (ch,p(1..ct)),(q(1..anzq)),rp;
  list lab;
  int pidx = 1;
  int qidx = 1;
  for (i = 1 ; i<=size(G.edges); i++){
      if (size((G.edges)[i])==1){
          lab[i]=p(pidx);
          pidx = pidx+1;
      } else {
          lab[i]=q(qidx);
          qidx = qidx+1;
      }
  }
  labeledgraph lG = makeLabeledGraph(G.vertices,G.edges,R, lab,P);
  if (ringdef){setring R1;}
  return(lG);
}
example
{ "EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4),list(list(1,3),list(1,2),list(2,4),list(3,4),list(1),list(2),list(3),list(4)));
  labeledgraph lG = labelGraph(G,0);
  lG;
}

proc balancingIdeal(labeledgraph G)
"USAGE:  balancingIdeal(G); G labeledgraph@*
ASSUME:  G is a labeled graph
RETURN:  ideal of balancing condition of the graph, basering is assumed to be G.over
KEYWORDS: Feynman graph
EXAMPLE:  example balancingIdeal; shows an example
"
{
 
  list v = G.vertices;
  list e = G.edges;
  list lab = G.labels;
  int i,j;
  ideal I;
  poly edg;
  poly rel;
  for (i = 1; i<=size(v); i++){
    edg=0;
    for (j = 1; j<=size(e); j++){
     if (size(e[j])==2){
       if (e[j][1]==v[i]){edg=edg+lab[j];}
       if (e[j][2]==v[i]){edg=edg-lab[j];}
     } else {
       if (e[j][1]==v[i]){edg=edg+lab[j];}
     }
    }
    I=I+ideal(edg);
  }
  for (j = 1; j<=size(e); j++){
   if (size(e[j])==1){
     rel=rel+lab[j];
   }
  }
  I=I,rel;
  return(I);
}
example
{ "EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4),list(list(1,3),list(1,2),list(2,4),list(3,4),list(1),list(2),list(3),list(4)));
  labeledgraph lG = labelGraph(G,0);
  def R= lG.over;
  setring R;
  ideal I = balancingIdeal(lG);
}


proc eliminateVariables(labeledgraph G)
"USAGE:  eliminateVariables(G); G labeledgraph@*
ASSUME:  G is a labeled graph
RETURN:  labeled graph with variables of the bounded edges eliminated according to balancing condition
KEYWORDS: Feynman graph
EXAMPLE:  example eliminateVariables; shows an example
"
{
  int ringdef = (typeof(basering)=="ring");
  if (ringdef){def R1 = basering;}
  def RP=G.overpoly;
  def R=G.over;
  setring R;
  ideal I = balancingIdeal(G);
  setring RP;
  ideal I = imap(R,I);
  option(redSB);
  I=std(I);
  poly ld;
  poly ta;
  labeledgraph G1=G;
  list eliminatedVariables;
  for (int i = 1; i<=size(I);i++){
     ld=lead(I[i]);
     ta=ld-I[i];
     setring R;
     poly ld = imap(RP,ld);
     eliminatedVariables[i]=ld;
     poly ta = imap(RP,ta);
     G1=substituteGraph(G1,ld,ta);
     kill ld,ta;
     setring RP; 
  ;}
  kill ld,ta;
  setring R;
  kill I;
  G1.elimvars=eliminatedVariables;
  kill eliminatedVariables;
  setring RP;
  kill I;
  if (ringdef){setring R1;}
return(G1);}
example
{ "EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4),list(list(1,3),list(1,2),list(2,4),list(3,4),list(1),list(2),list(3),list(4)));
  labeledgraph lG = labelGraph(G,0);
  eliminateVariables(lG);
}

proc deleteFromIntvec(intvec v, int j){
intvec w;
int idx=1;
for (int i = 1;i<=size(v);i++){
   if (j<>i){w[idx]=v[i];idx=idx+1;}
}
return(w);}


proc removeVariable(def R, int j)
"USAGE:  removeVariable(R); R ring@*
ASSUME:  R is a polynomial ring
RETURN:  polynomial ring with j-th variable removed
KEYWORDS: ring
EXAMPLE:  example removeVariable; shows an example
"
{
list L = ringlist(R);
int nv;
if ((j<1) or (j>(nvars(R)))){ERROR("Index out of range");}
L[2]=delete(L[2],j);
for (int i = 1;i<=size(L[3])-1;i++){
   nv=nv+size(L[3][i][2]);
   if (nv>=j){
      if (size(L[3][i][2])==1){L[3]=delete(L[3],i);break;}
      L[3][i][2]=deleteFromIntvec(L[3][i][2],j-nv+size(L[3][i][2]));
      break;
   }
}
def S = ring(L);
return(S);}
example
{ "EXAMPLE:"; echo=2;
ring R=0,(x,y,z),(lp(2),dp(1));
def S= removeVariable(R,2);
S;
}


proc removeParameter(def R, int j)
"USAGE:  removeParameter(R); R ring@*
ASSUME:  R is a polynomial ring
RETURN:  polynomial ring with j-th variable removed
KEYWORDS: ring
EXAMPLE:  example removeParameter; shows an example
"
{
list L0 = ringlist(R);
list L = L0[1];
int nv;
if ((j<1) or (j>(size(L[2])))){ERROR("Index out of range");}
L[2]=delete(L[2],j);
for (int i = 1;i<=size(L[3])-1;i++){
   nv=nv+size(L[3][i][2]);
   if (nv>=j){
      if (size(L[3][i][2])==1){L[3]=delete(L[3],i);break;}
      L[3][i][2]=deleteFromIntvec(L[3][i][2],j-nv+size(L[3][i][2]));
      break;
   }
}
L0[1]=L;
def S = ring(L0);
return(S);}
example
{ "EXAMPLE:"; echo=2;
ring R=(0,p(1),p(2),p(3)),(x,y,z),(lp(2),dp(1));
def S= removeParameter(R,2);
S;
}




proc substituteGraph(labeledgraph G, poly a, poly b)
"USAGE:  substituteGraph(G); G labeledgraph@*
ASSUME:  G is a labeled graph
RETURN:  substitute the variable a in the labeling by b
KEYWORDS: Feynman graph
EXAMPLE:  example eliminateVariables; shows an example
"
{
  list L=G.labels;
  for (int i = 1; i<=size(L);i++){
    L[i]=subst(L[i],a,b);
  }
  labeledgraph G1 = makeLabeledGraph(G.vertices,G.edges,G.over,L,G.overpoly);
return(G1);
}



proc feynmanDenominators(labeledgraph G)
"USAGE:  feynmanDenominators(G); G labeledgraph@*
ASSUME:  G is a labeled graph
RETURN:  ideal containing the propagators in the Feynman integral
KEYWORDS: Feynman graph
EXAMPLE:  example feynmanDenominators; shows an example
"
{
  list L = G.labels;
  def S= G.over;
  setring S;
  ideal J;
  for (int i = 1; i<=size(L);i++){
      if (size(G.edges[i])==2){J[i]=L[i]^2;}
  }
  return(J);
}
example
{ "EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4),list(list(1,3),list(1,2),list(2,4),list(3,4),list(1),list(2),list(3),list(4)));
  labeledgraph lG = labelGraph(G,0);
  labeledgraph lGelim = eliminateVariables(lG);
  def R = lGelim.over;
  setring R;
  ideal I = feynmanDenominators(lGelim);
  I;
}


proc propagators(labeledgraph G)
"USAGE:  propagators(G); G labeledgraph@*
ASSUME:  G is a labeled graph
RETURN:  ideal, containing the denominators in the Feynman integral
KEYWORDS: Feynman graph
EXAMPLE:  example propagators; shows an example
"
{
  list L = G.labels;
  def S= G.over;
  def RP= G.overpoly;
  setring S;
  ideal J;
  for (int i = 1; i<=size(L);i++){
      if (size(G.edges[i])==2){J[i]=L[i]^2;}
  }
  ideal infedges;
  for (i = 1; i<=size(G.edges);i++){
      if(size(G.edges[i])==1){infedges[i]=G.labels[i]^2;}
  }
  setring RP;
  ideal J = imap(S,J);
  ideal infedges = imap(S,infedges);
  J=reduce(J,std(infedges));
  setring S;
  J=imap(RP,J);
  return(J);
}
example
{ "EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4),list(list(1,3),list(1,2),list(2,4),list(3,4),list(1),list(2),list(3),list(4)));
  labeledgraph lG = labelGraph(G,0);
  labeledgraph lGelim = eliminateVariables(lG);
  def R = lGelim.over;
  setring R;
  ideal I = propagators(lGelim);
  I;
}

proc ISP(labeledgraph G)
"USAGE:  ISP(G); G labeledgraph@*
ASSUME:  G is a labeled graph
RETURN:  ideal, containing the irreducible scalar products, that is, those scalar product which are not linearly dependent on the propagators.
KEYWORDS: Feynman graph
EXAMPLE:  example ISP; shows an example
"
{
  int i;
  def S= G.over;
  def RP = G.overpoly;
  setring S;
  ideal J = propagators(G);
  list el = G.elimvars;
  ideal infedges;
  for (i = 1; i<=size(G.edges);i++){
      if(size(G.edges[i])==1){infedges[i]=G.labels[i];}
  }
  setring RP;
  ideal J = imap(S,J);
  ideal infedges = imap(S,infedges);
  J=J+infedges^2;
  if (not defined(el)){list el = imap(S,el);}
  for (i = 1; i<=size(el);i++){
      J=J+ideal(el[i]);
  }
  J=std(J);
  list L = kbase(J,2);
  ideal I = L[1..size(L)];
  kill J,infedges,el,L;
  setring S;
  return(imap(RP,I));
}
example
{ "EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(1,2),list(3,6),list(4,5),list(1,6),list(2,3),list(5,6),list(3,4),list(1),list(2),list(5),list(4)));
  labeledgraph lG = labelGraph(G,0);
  labeledgraph G1 = eliminateVariables(lG);
  G1;
  ring R= G1.over;
  setring R;
  R;
  ISP(G1);
}

proc removeElimVars(labeledgraph G)
"USAGE:  removeElimVars(G); G labeledgraph@*
ASSUME:  G is a labeled graph
RETURN:  Removes the variables from G.elimvars. This key is generated by the procedure eliminateVariables.
KEYWORDS: Feynman graph
EXAMPLE:  removeElimVars G; shows an example
"
{
labeledgraph G1;
def R= G.over;
def RP = G.overpoly;
G1.vertices=G.vertices;
G1.edges = G.edges;
setring R;
list el = G.elimvars;
list lb = G.labels;
list iv,ip;
int j,i;
for (i = 1; i<=size(el);i++){
  if (rvar(el[i])<>0){
     iv[size(iv)+1]=rvar(el[i]);
  } else {
     for (j=1;j<=npars(R);j++){ 
       if (par(j)==el[i]){ip[size(ip)+1]=j;break;}
     }
  }
}
iv = sort(iv)[1];
ip = sort(ip)[1];
def R1 = R;
for (i = size(iv); i>=1;i--){
  R1 = removeVariable(R1,iv[i]);
}
for (i = size(ip); i>=1;i--){
  R1 = removeParameter(R1,ip[i]);
}
kill iv;
setring RP;
list el = imap(R,el);
list iv;
for (i = 1; i<=size(el);i++){
  iv[size(iv)+1]=rvar(el[i]);
}
iv = sort(iv)[1];
def RP1 = RP;
for (int i = size(iv); i>=1;i--){
  RP1 = removeVariable(RP1,iv[i]);
}
setring R1;
G1.labels = imap(R,lb);
G1.over = R1;
G1.overpoly = RP1;
G1.elimvars =list();
return(G1);}
example
{ "EXAMPLE:"; echo=2;
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(1,2),list(3,6),list(4,5),list(1,6),list(2,3),list(5,6),list(3,4),list(1),list(2),list(5),list(4)));
  labeledgraph lG = labelGraph(G,0);
  labeledgraph G1 = eliminateVariables(lG);
  labeledgraph G2 = removeElimVars(G1);
  G2;
  ring R= G2.over;
  setring R;
  R;
  G2;
}


proc computeBaikovMatrix(def G0)
"USAGE:  computeBaikovMatrix(G); G labeledgraph, or G graph@*
ASSUME:  G is a Graph, or@*
         G is a labeled graph where redundant variables have been eliminated by 
         the procedure eliminateVariables, and deleted from the ring by the 
         procedure removeElimVars.
RETURN:  a labeled graph G1, computes the Baikov matrix of G defined in G1.baikovover and stores it in G1.baikovmatrix
KEYWORDS: Feynman graph
EXAMPLE:  removeElimVars G; shows an example
"
{
if (typeof(G0)=="graph"){
  labeledgraph lG = labelGraph(G0,0);
  labeledgraph G1 = eliminateVariables(lG);
  labeledgraph G2 = removeElimVars(G1);
  return(computeBaikovMatrix(G2));
}
if (typeof(G0)<>"labeledgraph"){
  ERROR("expected a graph or labeledgraph");
}
labeledgraph G = G0;
def R = G.over;
def RP = G.overpoly;
setring R;
ideal P = propagators(G);
ideal I = ISP(G);
ideal PI=P,I;
setring RP;
ideal PI = imap(R,PI);
int i,j;
ideal gram;
int idx=1;
int startvars= npars(R)+1;
for (i = 1;i<=nvars(RP);i++){
   for (j = 1;j<=nvars(RP);j++){
     if ((i>=startvars) or (j>=startvars)){
        gram[idx] = var(i)*var(j);
     } else {
        gram[idx] = 0;
     }
     idx++;
   }
}
for (i = 1;i<startvars;i++){
   for (j = i+1;j<startvars;j++){
      PI=PI,var(i)*var(j);
  }
}
matrix A = lift(PI,gram);
int m = npars(R);
int m2 = (m*(m-1)) div 2;
int mt= m2-1;
int n = ncols(PI)-m2;
ring Z = (0,t(1..mt)),(z(1..n)),dp;
matrix B[nvars(RP)][nvars(RP)];
int idx=1;
poly sumt;
list pq;
for (i=1; i<=m;i++){
  for (j=i+1; j<=m;j++){
    if (idx<=mt){
      B[i,j]=1/2*t(idx);
      sumt=sumt+1/2*t(idx);
      pq[idx] = 1/2*t(idx);
    } else {
      B[i,j]=-sumt;
      pq[idx]=-sumt;
    }
    B[j,i]=B[i,j];
    idx++;
  }
}
matrix zvars[1][n+m2] = z(1..n),pq[1..m2];
matrix A = imap(RP,A);
matrix Bentries = zvars * A;
matrix B1[nvars(RP)][nvars(RP)] = Bentries[1,1..ncols(Bentries)];
B=B+B1;
labeledgraph GG =G;
GG.baikovover=Z;
GG.baikovmatrix = B;
return(GG);}
example
{ "EXAMPLE:"; echo=2;labeledgraph G1 = computeBaikovMatrix(G);
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  ring RB= G1.baikovover;
  setring RB;
  RB;
  matrix B = G1.baikovmatrix;
  print(B);
}


proc computeM1(def G0)
"USAGE:  computeM1(G); G labeledgraph, or G graph@*
ASSUME:  G is a Graph, or@*
         G is a labeled graph where redundant variables have been eliminated by 
         the procedure eliminateVariables, and deleted from the ring by the 
         procedure removeElimVars.
RETURN:  The module M1 over G1.baikovover that requires to compute IBP identities 
KEYWORDS: Feynman graph
"
{
if (typeof(G0)=="graph"){
  labeledgraph G1 =computeBaikovMatrix(G0);
  return(computeM1(G1));
}
if (typeof(G0)<>"labeledgraph"){
  ERROR("expected a graph or labeledgraph");
}
labeledgraph G = G0;
def R = G.over;
int m=npars(R);
ring RB=G.baikovover;
matrix B=G.baikovmatrix;
setring RB;
int n=nvars(RB);
matrix C[n][n];
int tem=0;
int E = m;
int L = nvars(R);
list x;
for(int i=1;i<=E;i++){
  for(int j=E+1;j<=E+L;j++){ 
    tem=tem+1;
    x[tem]=[i,j];   
    for(int k=1;k<=n;k++){
      C[tem,k]=diff(B[i,j],z(k));
    }
  }
}
for(int i=E+1;i<=E+L;i++){
  for(int j=i;j<=E+L;j++){ 
    tem=tem+1;   
    x[tem]=[i,j];
    for(int k=1;k<=n;k++){
      C[tem,k]=diff(B[i,j],z(k));
    }
  }
}

matrix D=inverse(C);
module M;
int tem=1;
for(int i=E+1;i<=E+L;i++){
  for(int j=1;j<=E+L;j++){
    
    vector t=0*gen(n+1);
    for(int l=1;l<=n;l++){
      poly a=0;
      for(int k=1;k<=E+L;k++){
        //find the right row correspond to derivative
            int o=0;
            int c1;
            poly c2=0;
            if(i==k){
              c1=2;
            } else {
              c1=1;
            }
            
          for(int r=1;r<=size(x);r++){
            if([i,k]==x[r] or [k,i]==x[r] ){
              o=r;
              
            }
          }

          if(o<>0){
            c2=D[l,o];
          }
          a=a+c1*c2*B[j,k];
      }
    t=t+a*gen(l);
    }
    if(i==j){
      t=t-2*gen(n+1);
    } else {
      t=t+0*gen(n+1);
    }
    M[tem]=t;
    tem=tem+1;
  }
}
//Test the computation
poly F=det(B);
for(int j=1;j<size(M);j++){
  poly testP=0;
  for(int i=1;i<=n;i++){
    testP=testP+M[j][i]*diff(F,z(i));
    }
  testP=testP+M[j][n+1]*F;
  if(testP<>0){
    print("Something wrong");
  }

}

return(M);
}

example
{ "EXAMPLE:"; echo=2;labeledgraph G1 = computeBaikovMatrix(G);
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
    labeledgraph G1=computeBaikovMatrix(G);
   ring RB=G1.baikovover;
    RB;
    module ML=computeM1(G1);
}

proc computeM2(def G0,list Nu)
"USAGE:  computeM2(G); G labeledgraph, or G graph@*
ASSUME:  G is a Graph, or@*
         G is a labeled graph where redundant variables have been eliminated by 
         the procedure eliminateVariables, and deleted from the ring by the 
         procedure removeElimVars.
         Nu is the seed.
RETURN:  The module M2 over G1.baikovover that requires to compute IBP identities 
KEYWORDS: Feynman graph
"
{
  if (typeof(G0)=="graph"){
  labeledgraph G1 =computeBaikovMatrix(G0);
  return(computeM2(G1,Nu));
}
if (typeof(G0)<>"labeledgraph"){
  ERROR("expected a graph or labeledgraph");
}

labeledgraph G = G0;
def R = G.over;
int m=npars(R);
ring RB=G.baikovover;
matrix B=G.baikovmatrix;
setring RB;
int n=nvars(RB);

if(size(Nu)<>n){
   ERROR("The length of the vector nu must equal to number of Baikov variables");
}

int tem=0;
int E = m;
int L = nvars(R);

module M2;

for(int i=1;i<=n;i++){
  if(Nu[i]>0){
              M2[i]=z(i)*gen(i);
              } else {
                      M2[i]=1*gen(i);
                      }
}
M2[n+1]=1*gen(n+1);
return(M2);
}
example
{ "EXAMPLE:"; echo=2;labeledgraph G1 = computeBaikovMatrix(G);
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
    labeledgraph G1=computeBaikovMatrix(G);
   ring RB=G1.baikovover;
    RB;
    module M2=computeM2(G1,list(1,1,1,0,0,1,0,0,0));
    M2;
}



proc computeIBP(def G0,list Nu)
"USAGE:  computeIBP(G); G labeledgraph, or G graph@*
ASSUME:  G is a Graph, or@*
         G is a labeled graph where redundant variables have been eliminated by 
         the procedure eliminateVariables, and deleted from the ring by the 
         procedure removeElimVars.
         Nu is the seed.
RETURN:  The set of IBPS correspond to G0 and given Nu.
KEYWORDS: Feynman graph
"
{
if (typeof(G0)=="graph"){
  labeledgraph G1 =computeBaikovMatrix(G0);
  return(computeM2(G1,Nu));
}
if (typeof(G0)<>"labeledgraph"){
  ERROR("expected a graph or labeledgraph");
}

labeledgraph G = G0;
def R = G.over;
int m=npars(R);
ring RB=G.baikovover;
matrix B=G.baikovmatrix;
setring RB;
int n=nvars(RB);
int E = m;
int L = nvars(R);

if(size(Nu)<>n){
  ERROR("The length of the vector nu must equal to number of Baikov variables");
}

module M1=computeM1(G,Nu);
module M2=computeM2(G,Nu);
option(redSB);
module M=std(intersect(M1,M2));

// testing the generators satisfy the relation
poly F=det(B);
for(int j=1;j<size(M);j++){
  poly testP=0;
  for(int i=1;i<=n;i++){
    testP=testP+M[j][i]*diff(F,z(i));
    }
  testP=testP+M[j][n+1]*F;
  //print(testP);
  if(testP<>0){
    print("Something wrong");
  }
}
//

ring Z= (0,t(1..(m-1)),D),(z(1..n)),dp;
S.over=Z;
//S.over=RB;
S.seed=Nu;
setring Z;
module M=imap(RB,M);
int p=1;
for(int i=1;i<=size(M);i++){
  list y;
  list l;
  //computation of polynomial
  poly f=0;
  for(int j=1;j<=n;j++){
    f=f+(diff(M[i][j],z(j))-Nu[j]*M[i][j]/z(j));  
  }
  poly h=(D-L-E-1)/2;
  f=f-M[i][n+1]*h; 
  if(f<>0){
    int t=1;
      while(f<>0){
        y[t]=leadcoef(f);
        list nu;
        for(int k=1;k<=size(Nu);k++){
          nu[k]=Nu[k]-leadexp(f)[k];
        }
      l[t]=nu;
      t=t+1;
      f=f-lead(f);
      }
    oneIBP I;
    I.c=y;
    I.i=l;
    S.IBP[p]=I;
    p=p+1;  
  }

}

return(S);

}
example
{ "EXAMPLE:"; echo=2;labeledgraph G1 = computeBaikovMatrix(G);
  graph G = makeGraph(list(1,2,3,4,5,6),list(list(6,1),list(4,6),list(1,2),list(3,5),list(4,3),list(2,5),list(5,6),list(1),list(2),list(3),list(4)));
  labeledgraph G1=computeBaikovMatrix(G);
  setIBP S=computeIBP(G1,list(1,1,0,1,0,1,0,1,0));
  S;
  ring R=S.over;
  oneIBP I=S.IBP[5];
  I;

}
