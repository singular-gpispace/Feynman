using Oscar
#include("DataTypes.jl")


export printNet
export printGraph
export labelGraph
export printLabeledGraph
export balancingIdeal
export eliminateVariables
export removeVariable
export removeParameter
export removeVariableLocal
export substituteGraph
export removeElimVars
export feynmanDenominators
export propagators
export ISP
export computeBaikovMatrix
export computeM1
export computeIBP
export printIBP
export makePoly
#----------------------------------
export sample1
export Net
export simple_graph
export labeledgraph
export IBP

mutable struct sample1
    a::Int
end
mutable struct simple_graph
    vertices :: Vector{Int64}
    edges :: Vector
end

mutable struct Net
    rows :: Vector
end

mutable struct labeledgraph
    vertices :: Vector{Int64}
    edges :: Vector
    over :: Ring
    labels :: Vector
    overpoly ::Ring
    elimvar ::Vector
    baikovover :: Ring
    baikovmatrix :: Matrix{RingElem}
end

mutable struct IBP
    baikovind::Vector
    baikovover::Ring
    paraind::Int64
    setIBP::Vector
end

#----------------------------------

function printNet(N::Vector)
    println('[',join(repr.(N),", "),']');
end

## This is the print function to print a simple graph

```
"Setting a Feynman Graph"

```

@doc raw"""
printGraph(G::simple_graph)

**USAGE**   : prinGraph(G);

**ASSUME**  : G is a lsimple graph.

**Theory**: This is the print function used in julia to print a lsimple graph.

**#Examples**
```julia
julia> G=Feynman.simple_graph([1,2,3,4],[(1,4),(1,2),(2,3),(3,4),1,2,3,4]);

julia> printGraph(G);
Graph with 4 vertices and 4 bounded edges 4 unbounded edges
```
"""
function printGraph(G::simple_graph)
    num_ver=length(G.vertices);
    num_edg=length(G.edges);
   
    ct = count(e -> length(e)==1, G.edges)

    if ct!=0
        println("Graph with ", num_ver ," vertices and ",num_edg-ct ," bounded edges ",ct," unbounded edges")
    else
        println("Graph with ", num_ver ," vertices and ",num_edg ," edges")
    end
end


@doc raw"""
printLabeledGraph(G::labeledgraph)

**USAGE**   : printLabeledGraph(G);

**ASSUME**  : G is a labeled graph.

**Theory**: This is the print function used in julia to print a labeled graph.

**#Examples**
```julia
julia> var=["x","y","z","p","q","r"];
julia> R, (x,y,z,p,q,r)=polynomial_ring(QQ,var);
julia> G=labeledgraph([1,2,3,4],[(1,3),(1,2),(1,2),(2,4),(3,4),(3,4)],R,var,R,[3,4],R,[[y+1,R(2)] [R(3),r+3]]);
julia> printLabeledGraph(G);

Graph with 4 vertices and 6 edges
Edge terms:
["(1, 3)=>x", "(1, 2)=>y", "(1, 2)=>z", "(2, 4)=>p", "(3, 4)=>q", "(3, 4)=>r"]

```
"""
function printLabeledGraph(G::labeledgraph)
   
    printGraph(simple_graph(G.vertices,G.edges));
ev=String[];
println("Edge terms:");
for i in 1:length(G.edges)
    t=string(string(G.edges[i]),"=>",string(G.labels[i]));
    push!(ev,t) ;    
end
printNet(ev);
end


@doc raw"""
labelGraph(G::simple_graph,ch::Int)

**USAGE**   : labelGraph(G,ch);

**ASSUME**  : G is a graph and ch is either zero or prime.

**RETURN**  : labeled graph with polynomialvariables qi at the bounded edges and functin filed variables pi at the unbounded edges over a prime filed of characteristic ch
Initially we it sets the fields Baikovmatrix and elimvar empty.
 
**#Examples**
```julia
julia> G3=simple_graph([1,2,3,4],[(1,3),(1,2),(2,4),(3,4),1,2,3,4]);
julia> G4=labelGraph(G3,0);
julia> printLabeledGraph(G4);
Graph with 4 vertices and 4 bounded edges 4 unbounded edges
Edge terms:
["(1, 3)=>q[1]", "(1, 2)=>q[2]", "(2, 4)=>q[3]", "(3, 4)=>q[4]", "1=>p[1]", "2=>p[2]", "3=>p[3]", "4=>p[4]"]
```
"""
function labelGraph(G::simple_graph,ch::Int)
    if length(G.edges)==0
        error("Graph must have vertices")
    elseif ch<0

        error("ch must be nonnegative integer")
    
    end
    ct = count(e -> length(e)==1, G.edges)
    anzq=length(G.edges)-ct;
    
    ##P=(Z/pZ)[p(1),...,p(ct),q(1),...q(anzq)]
    if ch==0
        P,p,q=polynomial_ring(QQ,"p"=>(1:ct),"q"=>(1:anzq));
        #P,q,p=polynomial_ring(QQ,"q"=>(1:anzq),"p"=>(1:ct));
    else
        F=GF(ch);
        P,p,q=polynomial_ring(F,"p"=>(1:ct),"q"=>(1:anzq));
        #P,q,p=polynomial_ring(F,"q"=>(1:anzq),"p"=>(1:ct));
    end
    
    
   
    ##Q=complement_of_prime_ideal(ideal(P,p));
    Q=complement_of_prime_ideal(ideal(P,p));
    R,iso=localization(P,Q);

    ##Making list of labels
    pidx=1;
    qidx=1;
    lab=[];
    p=gens(R);
    for i in 1:length(G.edges)
        if length(G.edges[i])==1
            #lab[i]=p[pidx];
            push!(lab,p[pidx]);
            pidx=pidx+1;
        else
            #lab[i]=q[qidx];
            push!(lab,q[qidx]);
            qidx=qidx+1;
        end 
        
    end
    lG=labeledgraph(G.vertices,G.edges,R,lab,P,[],P,[;;]);
    return lG
end


```
"Computation of Baikov Matrix"
```

@doc raw"""
balancingIdeal(G::labeledgraph)

**USAGE**   : balancingIdeal(G);

**ASSUME**  : G is a labeled graph.

**RETURN**  : Ideal of balancing condition of the graph. i.e Ideal generated by the relation of the momentums which are obtained by applying momentum conservation law to external mementa,
        and at each vertex; This is an ideal of the ring G.over.

**#Examples**
```julia
julia> G=simple_graph([1,2,3,4],[(1,3),(1,2),(2,4),(3,4),1,2,3,4]);
julia> G=labelGraph(G,0);
julia> balancingIdeal(G)

Ideal generated by
p[1] + p[2] + p[3] + p[4]
p[1] + q[1] + q[2]
p[2] - q[2] + q[3]
p[3] - q[1] + q[4]
p[4] - q[3] - q[4]

```
"""
function balancingIdeal(G::labeledgraph)
 v=G.vertices;
 e=G.edges;
 lab=G.labels;
 R=G.over;
 edg=R(0);
 rel=R(0);
 w=Vector{typeof(R(1))}(undef,0);
 for i in 1:length(v)
    edg=R(0);#changed
    for j in 1:length(e)
        if length(e[j])==2
            if e[j][1]==v[i]
                edg=edg+R(lab[j]);
                
            end
            if e[j][2]==v[i]
                edg=edg-R(lab[j]);
            end
        else
            if e[j][1]==v[i]
                edg=edg+R(lab[j]);
            end
        end 

        
    end 
   push!(w,edg); #changed
 end   
 for j in 1:length(e)
    if length(e[j])==1
        rel=rel+R(lab[j]);
        
    end 
    
 end
 I=ideal(R,rel);#changed
 J=ideal(R,w);
 return I+J;
end


@doc raw""" 
substituteGraph(G::labeledgraph,a::RingElement,b::RingElement)

**USAGE**   :substituteGraph(G,a,b)

**ASSUME**  : G is a labeled graph

**RETURN**  :a labelled graph with labelling where each 'a' is replaced 'b'

"""
function substituteGraph(G::labeledgraph,a::RingElement,b::RingElement)
    L=G.labels;
    for i in 1:length(L)
       if L[i]==a
        L[i]=b;       
       end         
    end
   G.labels=L;
   return G; 
    
end


@doc raw"""
eliminateVariables(G::labeledgraph)

**USAGE**   :  eliminateVariables(G);

**ASSUME**  : G is a labeled graph.

**RETURN**  : labeled graph with variables of the bounded edges eliminated according to balancing condition.

#Examples
```julia
julia> G=simple_graph([1,2,3,4],[(1,3),(1,2),(2,4),(3,4),1,2,3,4]);
julia> G=labelGraph(G,0);
julia> G=eliminateVariables(G);
julia> printLabeledGraph(G);

Graph with 4 vertices and 4 bounded edges 4 unbounded edges
Edge terms:
["(1, 3)=>q[1]", "(1, 2)=>-p[1] - q[1]", "(2, 4)=>-p[1] - p[2] - q[1]", "(3, 4)=>-p[3] + q[1]", "1=>p[1]", "2=>p[2]", "3=>p[3]", "4=>-p[1] - p[2] - p[3]"]
julia> G.elimvar

4-element Vector{QQMPolyRingElem}:
 p[4]
 q[2]
 q[3]
 q[4]
```
"""
function eliminateVariables(G::labeledgraph)
  RP=G.overpoly;
  R=G.over;
  I=balancingIdeal(G); #Ideal in G.over
  n=ngens(I);
  #Need ring homomorphism from R to RP to get ideal 
  H=hom(R,RP,gens(RP));
  T=hom(RP,R,gens(R));
  v=[];
  for i in 1:n
    push!(v,H(I[i])); 
  end
  I=ideal(RP,v);

  #------Getting variables and parameters
  p=gens(base_ring(R));
  para=Vector{typeof(RP(1))}(undef,0);
  var=Vector{typeof(RP(1))}(undef,0);
  
  for i in 1:length(p) 
  
      if p[i] in inverted_set(R)
        push!(var,p[i]);
    
      else
          push!(para,p[i]); 
          
      end
        
  end

#--------------------------------------
#od=invlex(var)*invlex(para);
#od=lex(para,var);
od=invlex(RP);
#--------------------------------------
  I=standard_basis(I,ordering=od,complete_reduction=true);
#  I=standard_basis(I,ordering=od);
  #G1=G;
  eliminatedVariables=Vector{typeof(RP(1))}(undef,0);
  G.elimvar=Vector{typeof(RP(1))}(undef,0);
  n=length(I);
  for i in 1:n
    ld=leading_term(I[i],ordering=od);
    ta=ld-I[i];
    #ld=RP(ld);

    if !any(x -> x==ld || x==-ld, G.elimvar)
        push!(G.elimvar,H(T(ld)))
    end
    #ta=RP(ta); 
    G=substituteGraph(G,ld,ta);  
  end  
  #G.elimvar=Vector{typeof(RP(1))}(undef,0);
  #G.elimvar=eliminatedVariables;
  return G;
end


@doc raw"""
removeVariable(R::Ring,l::Vector)

**USAGE**:  removeVariable(G,l);

**ASSUME**: R is a polynomial ring.

**RERUTN**: polynomial ring with the vaiables at indeces given in l removed.

**#Examples**
```julia
julia> R,v=polynomial_ring(QQ,"p"=>(1:3));
julia> removeVariable(R,[2])
Multivariate polynomial ring in 2 variables p[1], p[3]
  over rational field
```
"""
function removeVariable(R::Ring,l::Vector)
    @req all(x -> x in 1:ngens(R), l) "Index out of range"
    
    v=deleteat!(copy(symbols(R)),l)
    R,c=polynomial_ring(coefficient_ring(R),v)
    return R
end


@doc raw"""
removeVariableLocal(P::Ring,l::Vector)

**USAGE**   : removeVariableLocal(P,l);

**ASSUME**  : P is a local ring locaized by the maximal ideal generated by parameters.

**RETURN**  : local ring where the variables at indeces in l removed. 

**#Examples**
```julia
ulia> P,p,q=polynomial_ring(QQ,"p"=>(1:4),"q"=>(1:5));

julia> Q=complement_of_prime_ideal(ideal(P,p));

julia> R,iso=localization(P,Q);

julia> removeVariableLocal(R,[1])
Localization
  of multivariate polynomial ring in 8 variables p[2], p[3], p[4], q[1], ..., q[5]
    over rational field
  at complement of prime ideal (p[2], p[3], p[4], q[1])
```
"""
function removeVariableLocal(P::Ring,l::Vector)

    R=base_ring(P);
    @req all(x -> x in 1:ngens(R), l) "Index out of range"

    v=deleteat!(copy(symbols(R)),l)
    #delete jth variable from base ring
    S,c=polynomial_ring(coefficient_ring(R),v);
    #-------
    u=[];
    k=0;
    genR=gens(R);
    for i in 1:length(genR) 
        #J=ideal(R,u);
        #L=complement_of_prime_ideal(J);
        if genR[i] in inverted_set(P) 
            
            continue;
        else
            push!(u,c[i]); 
            k=k+1;
        end
       
    end
    #-------
    #x=[];
   # for i in 1:k 
    #    push!(x,c[i]);
    #end
    #-------
    #w=deleteat!(x,j);
    J=ideal(S,u);
    U=complement_of_prime_ideal(J);
    T,iso=localization(S,U);
    return T;
    
end


@doc raw"""
removeParameter(P::Ring,l::Vector)

**USAGE**   : removeParameter(R,l);

**ASSUME**  : R is a polynomial ring.

**RETURN**  : polynomial ring with the parameters at indeces in l removed.

#Examples
```julia
julia> R,v,w=polynomial_ring(QQ,"p"=>(1:5),"q"=>(1:6));
julia> I=ideal(R,[v[1],v[2],v[3],v[4],v[5],w[1]]);
julia> u=complement_of_prime_ideal(I);
julia> S,iso=localization(R,u);
julia> S

julia> S
Localization
  of multivariate polynomial ring in 11 variables p[1], p[2], p[3], p[4], ..., q[6]
    over rational field
  at complement of prime ideal (p[1], p[2], p[3], p[4], p[5], q[1])


  julia> removeParameter(S,[2]) 
Localization
  of multivariate polynomial ring in 10 variables p[1], p[3], p[4], p[5], ..., q[6]
    over rational field
  at complement of prime ideal (p[1], p[3], p[4], p[5], q[1])
```
"""
function removeParameter(P::Ring,l::Vector)
    R=base_ring(P);
    @req all(x -> x in 1:ngens(R), l) "Index out of range"
    
    genR=deleteat!(gens(R),l);
    v=deleteat!(copy(symbols(R)),l)
    #delete jth variable from base ring
    S,c=polynomial_ring(coefficient_ring(R),v);
    #-------
    u=[];
    k=0;
    for i in 1:length(genR) 
        #J=ideal(R,u);
        #L=complement_of_prime_ideal(J);
        if genR[i] in inverted_set(P) 
            continue;
        else
            push!(u,c[i]); 
            k=k+1; 
        end
         
    end
    #-------
    #x=[];
   # for i in 1:k 
    #    push!(x,c[i]);
    #end
    #-------
    #w=deleteat!(x,j);
    #w=deleteat!(u,j);
    J=ideal(S,u);
    U=complement_of_prime_ideal(J);
    T,iso=localization(S,U);
    return T;
end


@doc raw"""
**feynmanDenominators(G::labeledgraph)**

**USAGE**   :  feynmanDenominators(G);

**ASSUME**  : $G$ is a labeled graph with the variables of the bounded edges eliminated according to balancing condition. i.e. $G$ is a labeled graph where 
        the function eliminatedVariables applied.

**RETURN**  : ideal containing the propagators in the Feynman integral

**#Examples**
```julia
julia> G=simple_graph([1,2,3,4],[(1,3),(1,2),(2,4),(3,4),1,2,3,4]);
julia> G=labelGraph(G,0);
julia> Gelim=eliminateVariables(G);
julia> feynmanDenominators(Gelim)
Ideal generated by
  q[1]^2
  p[1]^2 + 2*p[1]*q[1] + q[1]^2
  p[1]^2 + 2*p[1]*p[2] + 2*p[1]*q[1] + p[2]^2 + 2*p[2]*q[1] + q[1]^2
  p[3]^2 - 2*p[3]*q[1] + q[1]^2
```
"""
function feynmanDenominators(G::labeledgraph)
    L = G.labels
    S = G.over
    v = [L[i]^2 for i in 1:length(L) if length(G.edges[i])==2]
    return ideal(S,v);
end


@doc raw"""
**propagators(G::labeledgraph)**

**USAGE**:  propagators(G);

**ASSUME**: G is a labeld graph.

**RETURN**: ideal, containing the denominators in the Feynman integral.

**#Examples**
```julia
julia> G=simple_graph([1,2,3,4,5,6],[(6,1),(4,6),(1,2),(3,5),(4,3),(2,5),(5,6),1,2,3,4]);

julia> G=labelGraph(G,0);

julia> Gelim=eliminateVariables(G);

Gelim=removeElimVars(Gelim);

julia> propagators(Gelim)
Ideal generated by
  q[1]^2
  q[2]^2
  -2*p[1]*q[1] + q[1]^2
  2*p[1]*p[2] - 2*p[1]*q[2] - 2*p[2]*q[2] + q[2]^2
  -2*p[1]*q[2] - 2*p[2]*q[2] - 2*p[3]*q[2] + q[2]^2
  2*p[1]*p[2] - 2*p[1]*q[1] - 2*p[2]*q[1] + q[1]^2
  q[1]^2 - 2*q[1]*q[2] + q[2]^2
```
"""
function propagators(G::labeledgraph)
    L=G.labels;
    S=G.over;
    RP=G.overpoly;

    H=hom(S,RP,gens(RP))

    u = [H(L[i]^2) for i in 1:length(L) if length(G.edges[i])==2]
    J=ideal(RP,u);
    
    v = [H(L[i]^2) for i in 1:length(L) if length(G.edges[i])==1]
    infedges=ideal(RP,v);

    #reduce J w.r.t std basis of infedges
    SB_infedges=standard_basis(infedges,ordering=invlex(RP));
    
    N=reduce(gens(J), SB_infedges,ordering=invlex(RP),complete_reduction=true)
    
    #rewrite the ideal J as an ideal of S
    T=hom(RP,S,gens(S))
    
    J=ideal(S,T.(N))
    return J
end


@doc raw"""
ISP(G::labeledgraph)

**USAGE**   :  ISP(G);

**ASSUME**  : G is a labeled graph.

**RETURN**  : ideal containing the irreducible scalar products(ISPs). 

**THEORY**  :  An scalar product that cannot expressed interms of inverse propagators in called an irreducible scalar product

**#Examples**
```julia
julia> G=simple_graph([1,2,3,4,5,6],[(1,2),(3,6),(4,5),(1,6),(2,3),(5,6),(3,4),1,2,5,4]);

julia> G=labelGraph(G,0);

julia> Gelim=eliminateVariables(G);

julia> ISP(Gelim)
Ideal generated by
  p[3]*q[1]
  p[1]*q[2]

```
"""
function ISP(G::labeledgraph)
    S=G.over;
    RP=G.overpoly;
    J=Feynman.propagators(G);
    el=G.elimvar;
    x=gens(S);
    v = [G.labels[i] for i in 1:length(G.edges) if length(G.edges[i])==1]
    infedges=ideal(S,v);
    
    T=hom(S,RP,gens(RP));
    
    v=[];
    for i in 1:ngens(J)
    push!(v,T(J[i])); 
    end
    J=ideal(RP,v);
    
    v=[];
    for i in 1:ngens(infedges)
    push!(v,T(infedges[i])); 
    end
    infedges=ideal(RP,v);
    
    J=J+infedges^2;

    v=[];
    for i in 1:length(el)
    push!(v,T(el[i])); 
    end
    el=v;
    
    for i in 1:length(el)
    J=J+ideal(RP,el[i]);    
    end
    
    J=groebner_basis(J,ordering=invlex(RP));

    v=Vector{typeof(RP(1))}(undef,0);
    for i in 1:length(J)
    push!(v,T(J[i])); 
    end
    J=ideal(RP,v);

    w=Vector{typeof(RP(1))}(undef,0);   
    gens_RP=gens(RP);
    for i in 1:length(gens_RP) 
        Q,h=reduce_with_quotients(gens_RP[i]^2,v,ordering=invlex(RP),complete_reduction=true);
        if h!=0
            push!(w,h);
        end
        for j in i+1:length(gens_RP) 
        Q,h=reduce_with_quotients(gens_RP[i]*gens_RP[j],v,ordering=invlex(RP),complete_reduction=true);
        if h!=0
            push!(w,h);
        end
        end
    end
    
    K=ideal(RP,w);
    K=standard_basis(K,ordering=invlex(RP),complete_reduction=true);
    H=hom(RP,S,gens(S));
    u=Vector{typeof(S(1))}(undef,0);
    for i in 1:length(K) 
        push!(u,H(K[i]));
    end
    K=ideal(S,u);
    return K;
     
end


@doc raw"""
removeElimVars(G::labeledgraph)

**USAGE**   :  removeElimVars(G);

**ASSUME**  : G is a labled graph.

**RETURN**  : Removes the variables from G.elimvars. This key is generated by the procedure eliminatedVariables.

**#Examples**
```julia
julia> G=simple_graph([1,2,3,4,5,6],[(1,2),(3,6),(4,5),(1,6),(2,3),(5,6),(3,4),1,2,5,4]);

julia> G=labelGraph(G,0);

julia> Gelim=eliminateVariables(G);

julia> G=removeElimVars(Gelim);

julia> G.elimvar
Any[]
```
"""
function removeElimVars(G::labeledgraph)
    R=G.over;
    RP=G.overpoly;
    el=G.elimvar;
    lb=G.labels;
    
    p=gens(base_ring(R));
    para=[];
    
    for i in 1:length(p) 
    
        if p[i] in inverted_set(R)
            continue;
        else
            push!(para,p[i]); 
        end          
    end
    
    iv=[];
    ip=[];
    ia=[];
        for i in 1:length(el)
            t=findall(x->x==el[i],p);
            push!(ia,t[1]);
            if el[i] in para
                push!(ip,t[1]);
            else
                push!(iv,t[1]);
            end
                   
        end
    
    R1=R;
    RP1=RP;

    if length(iv)!=0
      R1=Feynman.removeVariableLocal(R1,iv);
    end

    if length(ip)!=0
      R1=Feynman.removeParameter(R1,ip); 
    end

    if length(ia)!=0
      RP1=Feynman.removeVariable(RP1,ia);
        
    end
    #G.labels=lb;
    

    gR1=gens(R1);
  
    u=Vector{typeof(R1(1))}(undef,ngens(R));
    for i in 1:ngens(R)
      u[i]=R1(0); 
    end

    j=1;
    for i in 1:length(u) 
      if i in ia
      continue;
      else
        u[i]=gR1[j];
        j=j+1;
      end
    end
    T=hom(R,R1,u);
    u=Vector{typeof(R1(1))}(undef,0);
    for i in 1:length(lb) 
      push!(u,T(lb[i]));
    end
    G.labels=u;
    G.over=R1;
    G.overpoly=RP1;
    G.elimvar=[];
     return G; 
end


@doc raw"""
computeBaikovMatrix(G::simple_graphgraph)

**USAGE**   :  computeBaikovMatrix(G);

**ASSUME**  : G is a graph, or G is a labled graph where redundant variables have been eliminated by the procedure eliminateVariables, and deleted from the 
            ring by the procedure removeElimVars.

**RETURN**  : a labeled graph G, where the computed Baikov matrix and the polynomial ring where baikovmatrix is defined are stored in G.baikovmatrix and G.baikovover respectively.

**THEORY**  :This function compute the Baikov representation of the given graph $G$, which holds the condition $n_{int} \leq N$. There, it will compute the so-called Baikov matrix, which is 
            the Gram matrix corresponding to the graph such that all scalar products are replaced by the corresponding expression of Baikov variables ($z_1,...,z_N$) and 
            kinematic variables ($t_i,\,i=1,..., N_B$), assuming $p_i^2=0$ for $i=1,...,n_{ext}$. The user only needs to provide the graph details in terms of vertices and edges

#Examples(If G considerd as labeled graph)
```julia
julia> G=simple_graph([1,2,3,4,5,6],[(6,1),(4,6),(1,2),(3,5),(4,3),(2,5),(5,6),1,2,3,4]);

julia> G=labelGraph(G,0);

julia> G=eliminateVariables(G);

julia> G=removeElimVars(G);

julia> G=computeBaikovMatrix(G);
labels used for Gram matrix of external loop momenta:
["p[1]*p[2] => 1//2*t[1]"]
["p[1]*p[3] => 1//2*t[2]"]
["p[2]*p[3] => -1//2*t[1] - 1//2*t[2]"]
Assignment of Baikov variables (Z_i) are:
["z[1] => p[3]*q[1]"]
["z[2] => q[1]^2"]
["z[3] => -2*p[1]*q[1] + q[1]^2"]
["z[4] => 2*p[1]*p[2] - 2*p[1]*q[1] - 2*p[2]*q[1] + q[1]^2"]
["z[5] => p[1]*q[2]"]
["z[6] => q[2]^2"]
["z[7] => 2*p[1]*p[2] - 2*p[1]*q[2] - 2*p[2]*q[2] + q[2]^2"]
["z[8] => -2*p[1]*q[2] - 2*p[2]*q[2] - 2*p[3]*q[2] + q[2]^2"]
["z[9] => q[1]^2 - 2*q[1]*q[2] + q[2]^2"]

julia> G.baikovmatrix
5×5 Matrix{RingElem}:
 0                      1//2*t[1]                                 …  1//2*z[2] - 1//2*z[3]              z[5]
 1//2*t[1]              0                                            1//2*t[1] + 1//2*z[3] - 1//2*z[4]  1//2*t[1] - z[5] + 1//2*z[6] - 1//2*z[7]
 1//2*t[2]              -1//2*t[1] - 1//2*t[2]                       z[1]                               -1//2*t[1] + 1//2*z[7] - 1//2*z[8]
 1//2*z[2] - 1//2*z[3]  1//2*t[1] + 1//2*z[3] - 1//2*z[4]            z[2]                               1//2*z[2] + 1//2*z[6] - 1//2*z[9]
 z[5]                   1//2*t[1] - z[5] + 1//2*z[6] - 1//2*z[7]     1//2*z[2] + 1//2*z[6] - 1//2*z[9]  z[6]
```

#Examples( if G considered as simple graph)
```julia
julia> G=simple_graph([1,2,3,4,5,6],[(6,1),(4,6),(1,2),(3,5),(4,3),(2,5),(5,6),1,2,3,4]);

julia> G=computeBaikovMatrix(G);
labels used for Gram matrix of external loop momenta:
["p[1]*p[2] => 1//2*t[1]"]
["p[1]*p[3] => 1//2*t[2]"]
["p[2]*p[3] => -1//2*t[1] - 1//2*t[2]"]
Assignment of Baikov variables (Z_i) are:
["z[1] => p[3]*q[1]"]
["z[2] => q[1]^2"]
["z[3] => -2*p[1]*q[1] + q[1]^2"]
["z[4] => 2*p[1]*p[2] - 2*p[1]*q[1] - 2*p[2]*q[1] + q[1]^2"]
["z[5] => p[1]*q[2]"]
["z[6] => q[2]^2"]
["z[7] => 2*p[1]*p[2] - 2*p[1]*q[2] - 2*p[2]*q[2] + q[2]^2"]
["z[8] => -2*p[1]*q[2] - 2*p[2]*q[2] - 2*p[3]*q[2] + q[2]^2"]
["z[9] => q[1]^2 - 2*q[1]*q[2] + q[2]^2"]
``` 

G.baikovmatrix is the Gram matrix where entries are replaced with Baikov variables:

$$\begin{bmatrix}
0 & 1//2*t[1] & 1//2*t[2] & 1//2*z[2] - 1//2*z[3] & z[5]\\ 
1//2*t[1] & 0 & -1//2*t[1] - 1//2*t[2] & 1//2*t[1] + 1//2*z[3] - 1//2*z[4] & 1//2*t[1] - z[5] + 1//2*z[6] - 1//2*z[7] \\ 
1//2*t[2] & -1//2*t[1] - 1//2*t[2] & 0 & z[1] & -1//2*t[1] + 1//2*z[7] - 1//2*z[8]\\
1//2*z[2] - 1//2*z[3] & 1//2*t[1] + 1//2*z[3] - 1//2*z[4] & z[1] & z[2] & 1//2*z[2] + 1//2*z[6] - 1//2*z[9]\\
z[5] & 1//2*t[1] - z[5] + 1//2*z[6] - 1//2*z[7] & -1//2*t[1] + 1//2*z[7] - 1//2*z[8] & 1//2*z[2] + 1//2*z[6] - 1//2*z[9] & z[6]\\
\end{bmatrix}$$

"""
function computeBaikovMatrix(G::simple_graph)
    G=labelGraph(G,0);
    G=eliminateVariables(G);
    G=removeElimVars(G);
return computeBaikovMatrix(G);
end


function computeBaikovMatrix(G::labeledgraph)
    if typeof(G)=="simple_graph"
        lG=labelGraph(G,0);
        G1=eliminateVariables(lG);
        G2=removeElimVars(G1);
        return computeBaikovMatrix(G2);
        
    end
    
    #if typeof(G)!="labeledgraph"
    ##    throw(error("expected a graph or labeledgraph"));
    # end

    R=G.over;
    RP=G.overpoly;
    P=Feynman.propagators(G);
    ngens(P)
    I=Feynman.ISP(G);
    PI=P+I;
    idx=0;
#-------------------------------------------------------------
    H=hom(R,RP,gens(RP));
    T=hom(RP,R,gens(R));
#--------------------------------------------------------------
    a=Vector{typeof(RP(1))}(undef,0);
    for i in 1:ngens(P) 
        push!(a,H(P[i]));
    end
    P=ideal(RP,a);
    v=Vector{typeof(RP(1))}(undef,0);
   
    for i in 1:ngens(P) 
        push!(v,P[i]);
       
    end
    
#-------------------------------------ordering elements
    npars=0;
    p=gens(base_ring(R));
    para=[];
    
    for i in 1:length(p) 
    
        if p[i] in inverted_set(R)
            continue;
        else
            push!(para,p[i]); 
            npars=npars+1;
        end
          
    end
    startvars=npars+1;
    varRP=gens(RP);
    #-----------------------------------------

    gram1=Vector{typeof(varRP[1])}(undef,0);

    #H=hom(R,RP,gens(RP));
    idx=0;
    for i in 1:length(varRP)
        for j in 1:length(varRP) 
        if (i>=startvars) || (j>=startvars)
            push!(gram1,H(varRP[i]*varRP[j]));
            idx=idx+1;
        else
            push!(gram1,RP(0));
        end 
        end
    
    end
    #gram1

#-----print gram vector as a matrix
    W=Matrix{typeof(RP(1))}(undef,ngens(RP),ngens(RP));    
    for j in 1:length(gram1)
            i=div(j,ngens(RP))+1;
            k=mod(j,ngens(RP));
            #print(gram1[j])
            if k==0
                W[i-1,ngens(RP)]=gram1[j];  
                #print("(",i-1,",",ngens(RP),")=",gram1[j])
            else
                W[i,k]=gram1[j];   
               # print("(",i,",",k,")=",gram1[j])
            end     
    end

    
#---Adding terms independent of loop momenta
    for i in 1:startvars-1 
        for j in i+1:startvars-1 
            PI=PI+ideal(R,[varRP[i]*varRP[j]]);
        end
    
    end
    #ngens(PI)
    #PI
#---Writing PI as an idal of RP

    a=Vector{typeof(RP(1))}(undef,0);
    for i in 1:ngens(PI) 
        push!(a,H(PI[i]));
    end
    PI=ideal(RP,a);
   
#---------------------------------

    v=Vector{typeof(RP(1))}(undef,0);
    for i in 1:ngens(PI) 
        push!(v,H(PI[i]));
    end

#---------------Ordering terms in IP appropreately for further calculations--------------------------
    o=invlex(RP);
    w=Vector{typeof(RP(1))}(undef,0);
    while length(v)!=0 
        k=1;
        for j in 2:length(v) 
            f=v[k];
            f1=leading_monomial(f,ordering=o);
            g=leading_monomial(v[j],ordering=o);
                    if cmp(o,f1,g)==1   
                        k=j;                            
                    end
            
        end
            push!(w,v[k]);
            deleteat!(v,[k]);       
    end
    v=w;
    PI=ideal(RP,v);

#----------------------------------
    m=length(para)
    m2=Int(m*(m-1)/2);  
    if m2==0
        mt=1;
    else
        mt=m2-1;
    end
    n=ngens(PI)-m2;

    #ngens(PI)
    Z=Feynman.makePoly(mt,n);
    t=gens(Z);
    t=deleteat!(t,mt+1);
    z=Vector{typeof(t[1])}(undef,0);
    for i in 1:n
        push!(z,t[mt+i]);         
    end
    
    B=zeros(Z,length(varRP),length(varRP));
    pq=Vector{typeof(t[1])}(undef,0);
    sumt=Z(0);

    idx=1;
    for i in 1:m
        for j in i+1:m 
            if idx<=mt
                B[i,j]=Z(1//2*t[idx]);
                sumt=sumt+Z(1//2*t[idx]);
                push!(pq,Z(1//2*t[idx]));
            else
                B[i,j]=-sumt;
                push!(pq,-sumt);
            end 
            B[j,i]=B[i,j];
            idx=idx+1;
        end 
    
    end


    zvar=Matrix{typeof(t[1])}(undef,1,n+m2);
    
    for i in 1:m2
        zvar[1,i]=pq[i];     
    end
    for i in 1:n    
        zvar[1,i+m2]=z[i]; 
    end

    #-----------------Printing of Baikov variable assigment
    ev=[];
    println("labels used for Gram matrix of external loop momenta:");
    for i in 1:m2 
        t=string(string(gens(PI)[i])," => ",string(zvar[i]));
        push!(ev,t);
        printNet(ev);
        ev=[];
    end
  
    println("Assignment of Baikov variables (Z_i) are:");
    ev=[];
    for i in 1:n 
        t=string(string(zvar[i+m2])," => ",string(gens(PI)[i+m2]));
        push!(ev,t);
        printNet(ev);
        ev=[];
    end
  

#---------------------------------------------------------
    X=ideal(RP,gram1);
#    is_subset(X,PI)
    H,I=groebner_basis_with_transformation_matrix(PI,ordering=invlex(RP));
    T,J=groebner_basis_with_transformation_matrix(X,ordering=invlex(RP));
    I1=Matrix{typeof(Z(1))}(undef,ngens(PI),length(H));
    I2=Matrix{Int}(undef,ngens(PI),length(H));
    I3=Matrix{typeof(RP(1))}(undef,ngens(PI),length(H));
    J1=Matrix{typeof(Z(1))}(undef,ngens(X),length(T));
#   gens(PI)*I==gens(H)
    #gens(PI)
    #gens(PI)
    y=Matrix{typeof(RP(1))}(undef,1,ngens(PI));
    for i in 1:ngens(PI) 
        y[1,i]=PI[i];
    end
    
    for i in 1:ngens(PI) 
        for j in 1:length(H)
            I1[i,j]=Z(constant_coefficient(I[i,j]));
            I2[i,j]=Int(constant_coefficient(I[i,j]));
        end
    end

    for i in 1:ngens(X)
        for j in 1:length(T) 
           J1[i,j]=Z(constant_coefficient(RP(J[i,j])));
           
        end
        
    end

    v=Vector{typeof(RP(1))}(undef,0);
    w=Vector{typeof(RP(1))}(undef,0);
    V=Matrix{typeof(RP(1))}(undef,1,length(H));
    for i in 1:length(H) 
        push!(v,H[i]);
        V[1,i]=H[i];
    end
    for i in 1:length(T) 
        push!(w,T[i]);
    end

   # is_subset(ideal(RP,w),ideal(RP,v))

    A=Matrix{typeof(Z(1))}(undef,length(v),length(gram1));
    D=Matrix{typeof(Z(1))}(undef,length(v),length(gram1));

    for i in 1:length(gram1)
         u=reduce_with_quotients(gram1[i],v,ordering=invlex(RP));
         #print(u)
            for j in 1:length(u[1]) 
                if u[1][j]==0
                    A[j,i]=Z(0);
                    D[j,i]=RP(0)
                else
                    A[j,i]=Z(constant_coefficient(u[1][j]));
                    D[j,i]=RP(u[1][j]);

                end
            end 
    end

    #transpose(V*D)
    f=Matrix{typeof(RP(1))}(undef,nrows(I),ncols(I));
    for i in 1:nrows(I)
        for j in 1:ncols(I)
            f[i,j]=RP(I[i,j]);
        end 
        
    end
    #transpose(y*f*D)

    #Bentries=zvar*transpose(I1)*A
    Bentries=zvar*I1*A;
    B1=Matrix{typeof(Z(1))}(undef,ngens(RP),ngens(RP));    
    for j in 1:length(Bentries)
            i=div(j,ngens(RP))+1;
            k=mod(j,ngens(RP));
            if k==0
                B1[i-1,ngens(RP)]=Bentries[1,j];  
            else
                B1[i,k]=Bentries[1,j];   
            end     
    end
    
    B=B1+B;
    G.baikovover=Z;
    G.baikovmatrix=B;
    return G;


    
end


@doc raw"""
makePoly(n::Int,m::Int)

**USAGE**   :  makePoly(m,n);

**ASSUME**  : m and n are positve integers.

**RETURN**  : A polynomial ring with vatiables t[1],...,t[n],D,z[1],...,z[m] over QQ. 

**#Examples**
```julia
julia> makePoly(2,3)
Multivariate polynomial ring in 6 variables t[1], t[2], D, z[1], ..., z[3]
  over rational field
```
"""
function makePoly(n::Int,m::Int)
    v=Vector{String}(undef,0);
    for i in 1:n 
        push!(v,"t[$i]");  
    end
        push!(v,"D");
    for i in 1:m 
        push!(v,"z[$i]");  
    end
    #Z,t,z=polynomial_ring(QQ,"t"=>(1:n),"z"=>(1:m));
    Z,t=polynomial_ring(QQ,v);
    return Z;
end


```
"Computation of set of integration-by-part(IBP) relations"
```

@doc raw"""
computeIBP(G::simple_graph,Nu::Vector{Int64},cutDeg::Int,showGens::Bool)
computeIBP(G::labeledgraph,Nu::Vector{Int64},cutDeg::Int,showGens::Bool)
computeIBP(G::labeledgraph,Nu::Vector{Int64},cutDeg::Int)

**USAGE**   :  computeIBP(G,ν,d); 

**ASSUME**  : G is a labeled graph, d is a positive integer and ν is vector of integers correspond to the parent diagram of the integral.

**RETURN**  : A set of simplified IBP identities without double propagators (without performing trimming) . 

**Examples**
```julia
julia> G=simple_graph([1,2,3,4],[(1,4),(1,2),(2,3),(3,4),1,2,3,4]);
julia> set_IBP=computeIBP(G,[1,1,1,0],8,true);
labels used for Gram matrix of external loop momenta:
["p[1]*p[2] => 1//2*t[1]"]
["p[1]*p[3] => 1//2*t[2]"]
["p[2]*p[3] => -1//2*t[1] - 1//2*t[2]"]
Assignment of Baikov variables (Z_i) are:
["z[1] => q[1]^2"]
["z[2] => 2*p[1]*q[1] + q[1]^2"]
["z[3] => 2*p[1]*p[2] + 2*p[1]*q[1] + 2*p[2]*q[1] + q[1]^2"]
["z[4] => 2*p[1]*q[1] + 2*p[2]*q[1] + 2*p[3]*q[1] + q[1]^2"]

julia> printIBP(set_IBP.setIBP,3);
First 3 IBP identities associated to G  (Total number of relations=22):
0=(-t[1]^2 - t[1]*t[2] + t[1] + t[2] - D + 6)I(0,-1,-1,0)+(t[1]^2 + t[1]*t[2] + 2)I(0,-1,-2,1)+(t[1]^2 + t[1]*t[2] + 2*t[1] + 2*t[2] + 2)I(0,-2,-1,1)+(t[1]^2 + t[1]*t[2] + D - 6)I(-1,-1,-1,0)+(-2*t[1]^2 - 2*t[1])I(-2,-1,-1,1)+(-t[1]*D + 5*t[1] - t[2]*D + 7*t[2])I(0,-1,-1,1)+(-t[1]*D + 10*t[1] - 8)I(-1,0,-1,1)+(t[1]*D - 6*t[1] + t[2]*D - 6*t[2])I(-1,-1,0,1)+(t[1]*D - 7*t[1] + 8)I(-1,-1,-1,1)+(t[1] + t[2])I(1,-1,-1,0)+(-t[1] - t[2])I(1,-1,-2,1)+(-t[1] - t[2])I(1,-2,-1,1)+(-t[1] + D - 6)I(0,0,-1,0)+(t[1] - 2)I(0,0,-2,1)+(t[1] - t[2] + D - 7)I(0,-1,0,0)+(t[1])I(0,-1,-2,2)+(t[1] + 1)I(0,-1,-2,0)+(-t[1] + t[2] - 1)I(0,-2,0,1)+(t[1] + t[2] - 1)I(0,-2,0,0)+(t[1])I(0,-2,-1,2)+(t[1] - D + 7)I(-1,0,-1,0)+(-2*t[1] + 4)I(-1,0,-2,2)+(-3*t[1] - t[2] - D + 5)I(-1,-1,0,0)+(2*t[1] - 4)I(-1,-1,-2,2)+(-2*t[1])I(-1,-1,-2,1)+(-t[1])I(-1,-1,-2,0)+(2*t[1] + 1)I(-1,-2,0,1)+(-t[1] - t[2])I(-1,-2,0,0)+(2*t[1] + 2*t[2] - 4)I(-1,-2,-1,2)+(-4*t[1] - 4*t[2])I(-1,-2,-1,1)+(-2*t[1] + 4)I(-2,0,-1,2)+(2*t[1])I(-2,0,-1,1)+(t[1])I(-2,0,-1,0)+(2*t[1] + 1)I(-2,-1,0,1)+(-t[1])I(-2,-1,0,0)+(-D + 8)I(0,0,0,0)+(D - 7)I(-1,0,0,0)+(-1)I(1,-1,-2,0)+(1)I(1,-2,0,0)+(-1)I(1,-2,-1,0)+(-1)I(0,-2,1,0)+(1)I(0,-2,-1,0)+(6)I(-1,0,-1,2)+(-2)I(-1,0,-2,3)+(-6)I(-1,-1,-1,2)+(2)I(-1,-1,-2,3)+(1)I(-1,-2,1,0)+(2)I(-1,-2,-1,3)+(-1)I(-2,0,0,1)+(-1)I(-2,0,0,0)+(-2)I(-2,0,-1,3)+(1)I(-2,-1,1,0)+(2)I(-2,-1,-1,3)+(-4)I(-2,-1,-1,2)

0=(-t[1] - 1)I(0,-1,-2,0)+(t[1])I(-1,-1,-2,0)+(t[1] + 1)I(-2,-1,0,0)+(-t[1])I(-2,-1,-1,0)+(1)I(1,-1,-2,0)+(-1)I(1,-2,0,0)+(1)I(1,-2,-1,0)+(-1)I(0,-1,-1,0)+(1)I(0,-2,1,0)+(-1)I(0,-2,-1,0)+(1)I(-1,-1,0,0)+(-1)I(-1,-2,1,0)+(1)I(-1,-2,0,0)+(-1)I(-2,-1,1,0)

0=(-t[1] - t[2])I(0,-2,-1,0)+(t[1] + t[2])I(-1,-2,-1,0)+(-t[1])I(-2,0,-1,0)+(t[1])I(-2,-1,-1,0)+(-1)I(0,0,-1,0)+(1)I(0,0,-2,1)+(1)I(0,-1,-1,0)+(-1)I(0,-1,-2,1)+(1)I(0,-2,0,0)+(-1)I(0,-2,-1,1)+(1)I(-1,0,-1,0)+(-1)I(-1,0,-2,1)+(-1)I(-1,-1,-1,0)+(1)I(-1,-1,-2,1)+(-1)I(-1,-2,0,0)+(1)I(-1,-2,-1,1)+(1)I(-2,0,0,0)+(-1)I(-2,0,-1,1)+(-1)I(-2,-1,0,0)+(1)I(-2,-1,-1,1)

```
"""
function computeIBP(G::simple_graph,Nu::Vector{Int64},cutDeg::Int,showGens::Bool)
    G=Feynman.labelGraph(G,0);
    G=Feynman.eliminateVariables(G);
    G=Feynman.removeElimVars(G);
    G=Feynman.computeBaikovMatrix(G);
    return computeIBP(G,Nu,cutDeg,showGens);
end


function computeIBP(G::simple_graph,Nu::Vector{Int64},cutDeg::Int)
    G=Feynman.labelGraph(G,0);
    G=Feynman.eliminateVariables(G);
    G=Feynman.removeElimVars(G);
    G=Feynman.computeBaikovMatrix(G);
    return computeIBP(G,Nu,cutDeg,true);
end


function computeIBP(G::labeledgraph,Nu::Vector{Int64},cutDeg::Int)
    return computeIBP(G,Nu,cutDeg,true);
end


function computeIBP(G::labeledgraph,Nu::Vector{Int64},cutDeg::Int,showGens::Bool)

    RZ=G.baikovover;
    R=G.over;
    gens_RZ=gens(RZ);
    B=G.baikovmatrix;
#-----------------------------------------------------------------------------------#
    C=matrix(RZ, G.baikovmatrix)
    f=det(C);  
#-----------------------------------------------------------------------------------#
#Compute E and Count L
   npars=0;
   p=gens(base_ring(R));
   para=[];
   for i in 1:length(p) 
       if p[i] in inverted_set(R)
           continue;
       else
           push!(para,p[i]); 
           npars=npars+1;
       end
         
   end
   m=length(para);
   E=m;
   m2=Int(m*(m-1)/2);
   mt=0;  
   if m2==0
       mt=1;
   else
       mt=m2-1;
   end
   L=length(p)-E;        
   #----------Getting t vector and z vector-------------
   var_t=gens_RZ[1:mt]
   var_z=gens_RZ[mt+2:end]

    if length(Nu)!=length(var_z)
        error("length of the vector nu must equal to number of Baikov variables");
    end  

#-------------Computing generators of M1--------------------------
   t=computeM1(G);
   n=L*E+Int(L*(L+1)/2);
#=Test for whether the computed generators are correct

    for j in 1:length(t) 
        g=RZ(0);
    for i in 1:(length(t[1])-1) 
        g=g+t[j][i]*derivative(f,length(var_t)+1+i);
    end
        println(g+t[j][length(t[1])]*f)
    end
=#
    m=length(var_z);


#-----------------------------------------------------------------------------------#
# --------------compute module intersection and  Groebner basis---------------------#
#-----------------------------------------------------------------------------------#

##------Defining the polynomial ring RZ in Singular----------------------------------#
    v=["t[$i]" for i in 1:length(var_t)]
    push!(v,"D");
    append!(v, ["z[$i]" for i in 1:length(var_z)])

    T,var=Singular.polynomial_ring(Singular.QQ,v,ordering=Singular.ordering_ls(length(v1))*Singular.ordering_dp(),degree_bound=cutDeg);
##-------Build the module M1----------------------------------------------------------#

    gens_M1=[];
    for i in 1: length(t)#size(A)[2]
        v=Vector{typeof(T(1))}(undef,0);
   #u=transpose(A[:,i]);
        u=t[i];
    for j in 1:length(u)-1 
        push!(v,T(u[j]))  
    end
        push!(gens_M1,Singular.vector(T,v...))
   
    end
    M1=Singular.Module(T,gens_M1...);

##--------Build the module M2-----------------------------------------------------------#
    gens_M2=[];
    for j in 1:length(t[1])-1
    v=Vector{typeof(T(1))}(undef,0);;
    for i in 1:length(t[1])-1 
        if i==j && j<=length(t[1])-1
             if Nu[j]>0 
                 push!(v,T(var_z[j]));       
            else #j<=length(t[1]) #j<=length(t[1])-1
                push!(v,T(1));
            end
    
        else
                push!(v,T(1));
        end          
    end 
    push!(gens_M2,Singular.vector(T,v...));
    end

    M2=Singular.Module(T,gens_M2...);
  
 #=   if showGens
 #   println("Generators of M1 are:");
    printNet(gens_M1);
    println("Generators of M2 are:");
    printNet(gens_M2);
   end
   =# 
##-------------------Compute Module intersection------------------------------------------# 
    G=Singular.intersection(M1,M2);
    G=Singular.std(G,complete_reduction=true);

#-----------------------------------------------------------------------------------#
# ------compute IBP identities correspond to generators of the Groebner basis--------#
#------------------------------------------------------------------------------------#

##------Convert generators of Groebner basis (in Singular) to generators in Oscar-----
    vecG=[];
    for i in 1:Singular.number_of_generators(G) 
        u=Singular.Base.Array(G[i]);
        v=[];
        for j in 1:length(u) 
            push!(v,RZ(u[j]));
        end
   
       push!(vecG,v);
    end

#--------------------------------------------------
#--------------------------------------------------
    for j in 1:length(vecG) 
        w=vecG[j]
        g=RZ(0);
        for i in 1:length(w) 
            g=g+w[i]*derivative(f,length(var_t)+1+i);
        end

        if g==0
            bj=0;
            hj=0;
            push!(vecG[j],bj[1]);
        else
       #e=j-invP;
            bj, hj = reduce_with_quotients(g, [f], ordering = invlex(RZ));
            if hj==0
                push!(vecG[j],bj[1]);
            else
            deleteat!(VecG,j);
            end
        end

    end

#------------------test again for correct calculation
    for i in 1:length(vecG) 
        w=vecG[i]
        g=RZ(0);
        for i in 1:length(w)-1 
            g=g+w[i]*derivative(f,length(var_t)+1+i);
        end
        
        if g-w[length(w)]*f!=0
            println("Something wrong in generating module intersection");
        end
        
    end  

##---------------Computation of IBP identities------------------------------------------------
    set_IBP=[];
    for i in 1:length(vecG) 
        u=vecG[i];
        v=[];
        proz=RZ(1);        
        for j in 1:m
            proz=proz*var_z[j];
        end

        for j in 1:length(u)-1 
       
               if u[j]==0
                   bj=0;
                     hj=0;
                else
              #e=j-invP;
                    g=proz*u[j];
                    bj, hj = reduce_with_quotients(g, [var_z[j]], ordering = invlex(RZ));
                end
                push!(v,bj[1]);      
        end
   #Compute Baikov identity associated to generator vecG[i]
   ##---1---compute m1= (\sum_{i=1}^{m}\frac{\partial a_i}{\partial z_i}
        m1=RZ(0);
        for j in 1:length(u)-1 
            m1=m1+derivative(u[j],length(var_t)+1+j);
        end
   ##---2---compute m3=\sum_{i=1}^{m} \frac{\nu_i a_i}{z_i}
        m2=RZ(0);
        for j in 1:length(u)-1 
            m2=m2+RZ(Nu[j])*v[j];
        end
   M=RZ((m1-(gens_RZ[length(var_t)+1]-L-E-1)*RZ(1//2)*u[m+1])*proz-m2);
        single_IBP=[];
        single_IBP_i=[];
        single_IBP_c=[];
        for j in 1:length(M) 
            degT=degrees(monomial(M,j)); #degree sequence of (t1,...,t_k,D,z_1,...,z_m)
            deg_t=first(degT,length(var_t)+1);
            deg_z=last(degT,length(var_z));
            cTerm=RZ(1);
            for l in 1:length(var_t)+1
          #cTerm=cTerm*var_t[l]^deg_t[l];
                cTerm=cTerm*gens(RZ)[l]^deg_t[l];
            end
            cTerm=cTerm*coeff(M,j);
            iTerm=deg_z-Nu;
       #Since we multiplied the expression by prod_z, 
            for l in 1:length(iTerm) 
                iTerm[l]=iTerm[l]-1;
            end
            push!(single_IBP,[cTerm,iTerm]);
            push!(single_IBP_c,cTerm);
            push!(single_IBP_i,iTerm);
        end
        if single_IBP!=[]
            #Need to simplify the IBP
            IBP=[];
            while length(single_IBP_i)!=0
                w=single_IBP_i[1];
                ind=findall(x->x==w,single_IBP_i);
                coef=RZ(0);
                for l in 1:length(ind) 
                    coef=coef+single_IBP_c[ind[l]];
                end
                push!(IBP,[coef,w]);
                deleteat!(single_IBP_i,ind);
                deleteat!(single_IBP_c,ind);
            end
            push!(set_IBP,IBP);   
        end
    end
 
return IBP(Nu,RZ,length(v1),set_IBP);
end


@doc raw"""
printIBP(set_IBP::Vector{Vector{}},n::Int64)

**USAGE**   :  printIBP(set_IBP,n); 

**ASSUME**  : set_IBP is the output of computeIBP

**RETURN**  : It prints first n IBP relations 

**Examples**
```julia
julia> G=simple_graph([1,2,3,4],[(1,4),(1,2),(2,3),(3,4),1,2,3,4]);
julia> set_IBP=computeIBP(G,[1,1,1,0],8,true);
labels used for Gram matrix of external loop momenta:
["p[1]*p[2] => 1//2*t[1]"]
["p[1]*p[3] => 1//2*t[2]"]
["p[2]*p[3] => -1//2*t[1] - 1//2*t[2]"]
Assignment of Baikov variables (Z_i) are:
["z[1] => q[1]^2"]
["z[2] => 2*p[1]*q[1] + q[1]^2"]
["z[3] => 2*p[1]*p[2] + 2*p[1]*q[1] + 2*p[2]*q[1] + q[1]^2"]
["z[4] => 2*p[1]*q[1] + 2*p[2]*q[1] + 2*p[3]*q[1] + q[1]^2"]

julia> printIBP(set_IBP.setIBP,3);
First 3 IBP identities associated to G  (Total number of relations=22):
0=(-t[1]^2 - t[1]*t[2] + t[1] + t[2] - D + 6)I(0,-1,-1,0)+(t[1]^2 + t[1]*t[2] + 2)I(0,-1,-2,1)+(t[1]^2 + t[1]*t[2] + 2*t[1] + 2*t[2] + 2)I(0,-2,-1,1)+(t[1]^2 + t[1]*t[2] + D - 6)I(-1,-1,-1,0)+(-2*t[1]^2 - 2*t[1])I(-2,-1,-1,1)+(-t[1]*D + 5*t[1] - t[2]*D + 7*t[2])I(0,-1,-1,1)+(-t[1]*D + 10*t[1] - 8)I(-1,0,-1,1)+(t[1]*D - 6*t[1] + t[2]*D - 6*t[2])I(-1,-1,0,1)+(t[1]*D - 7*t[1] + 8)I(-1,-1,-1,1)+(t[1] + t[2])I(1,-1,-1,0)+(-t[1] - t[2])I(1,-1,-2,1)+(-t[1] - t[2])I(1,-2,-1,1)+(-t[1] + D - 6)I(0,0,-1,0)+(t[1] - 2)I(0,0,-2,1)+(t[1] - t[2] + D - 7)I(0,-1,0,0)+(t[1])I(0,-1,-2,2)+(t[1] + 1)I(0,-1,-2,0)+(-t[1] + t[2] - 1)I(0,-2,0,1)+(t[1] + t[2] - 1)I(0,-2,0,0)+(t[1])I(0,-2,-1,2)+(t[1] - D + 7)I(-1,0,-1,0)+(-2*t[1] + 4)I(-1,0,-2,2)+(-3*t[1] - t[2] - D + 5)I(-1,-1,0,0)+(2*t[1] - 4)I(-1,-1,-2,2)+(-2*t[1])I(-1,-1,-2,1)+(-t[1])I(-1,-1,-2,0)+(2*t[1] + 1)I(-1,-2,0,1)+(-t[1] - t[2])I(-1,-2,0,0)+(2*t[1] + 2*t[2] - 4)I(-1,-2,-1,2)+(-4*t[1] - 4*t[2])I(-1,-2,-1,1)+(-2*t[1] + 4)I(-2,0,-1,2)+(2*t[1])I(-2,0,-1,1)+(t[1])I(-2,0,-1,0)+(2*t[1] + 1)I(-2,-1,0,1)+(-t[1])I(-2,-1,0,0)+(-D + 8)I(0,0,0,0)+(D - 7)I(-1,0,0,0)+(-1)I(1,-1,-2,0)+(1)I(1,-2,0,0)+(-1)I(1,-2,-1,0)+(-1)I(0,-2,1,0)+(1)I(0,-2,-1,0)+(6)I(-1,0,-1,2)+(-2)I(-1,0,-2,3)+(-6)I(-1,-1,-1,2)+(2)I(-1,-1,-2,3)+(1)I(-1,-2,1,0)+(2)I(-1,-2,-1,3)+(-1)I(-2,0,0,1)+(-1)I(-2,0,0,0)+(-2)I(-2,0,-1,3)+(1)I(-2,-1,1,0)+(2)I(-2,-1,-1,3)+(-4)I(-2,-1,-1,2)

0=(-t[1] - 1)I(0,-1,-2,0)+(t[1])I(-1,-1,-2,0)+(t[1] + 1)I(-2,-1,0,0)+(-t[1])I(-2,-1,-1,0)+(1)I(1,-1,-2,0)+(-1)I(1,-2,0,0)+(1)I(1,-2,-1,0)+(-1)I(0,-1,-1,0)+(1)I(0,-2,1,0)+(-1)I(0,-2,-1,0)+(1)I(-1,-1,0,0)+(-1)I(-1,-2,1,0)+(1)I(-1,-2,0,0)+(-1)I(-2,-1,1,0)

0=(-t[1] - t[2])I(0,-2,-1,0)+(t[1] + t[2])I(-1,-2,-1,0)+(-t[1])I(-2,0,-1,0)+(t[1])I(-2,-1,-1,0)+(-1)I(0,0,-1,0)+(1)I(0,0,-2,1)+(1)I(0,-1,-1,0)+(-1)I(0,-1,-2,1)+(1)I(0,-2,0,0)+(-1)I(0,-2,-1,1)+(1)I(-1,0,-1,0)+(-1)I(-1,0,-2,1)+(-1)I(-1,-1,-1,0)+(1)I(-1,-1,-2,1)+(-1)I(-1,-2,0,0)+(1)I(-1,-2,-1,1)+(1)I(-2,0,0,0)+(-1)I(-2,0,-1,1)+(-1)I(-2,-1,0,0)+(1)I(-2,-1,-1,1)

```
"""
function printIBP(set_IBP::Vector,n::Int64)
    
    if n>length(set_IBP)
        error("N must be less or equal to number of IBP identities");
    end
    println("First ",n," IBP identities associated to G  (Total number of relations=",length(set_IBP),"):")
   
    for j in 1:n
        ve=set_IBP[j];
        ev=[];
    for i in 1:length(ve) 
        t1=join(repr.(ve[i][2]),",");
        t=string(string("("),string(ve[i][1]),string(")"),string("I("),t1,string(")"));
        push!(ev,t);
    end
    println('0','=',join(ev,"+")); 
     println();   
    end
end


@doc raw"""
computeM1(G::labeledgraph)

**USAGE**   :  computeM1(G); 

**ASSUME**  : G is the output of computeBaikovMatrix. 

**RETURN**  : It computes the module M1 associated to graph $G$ which uses in the powerful module intersection method

**Examples**
```julia
julia> G=simple_graph([1,2,3,4],[(1,4),(1,2),(2,3),(3,4),1,2,3,4]);
julia> G=computeBaikovMatrix(G);
labels used for Gram matrix of external loop momenta:
["p[1]*p[2] => 1//2*t[1]"]
["p[1]*p[3] => 1//2*t[2]"]
["p[2]*p[3] => -1//2*t[1] - 1//2*t[2]"]
Assignment of Baikov variables (Z_i) are:
["z[1] => q[1]^2"]
["z[2] => 2*p[1]*q[1] + q[1]^2"]
["z[3] => 2*p[1]*p[2] + 2*p[1]*q[1] + 2*p[2]*q[1] + q[1]^2"]
["z[4] => 2*p[1]*q[1] + 2*p[2]*q[1] + 2*p[3]*q[1] + q[1]^2"]

julia> computeM1(G)
4-element Vector{Any}:
 QQMPolyRingElem[-z[1] + z[2], -z[1] + z[2], t[1] - z[1] + z[2], t[1] + t[2] - z[1] + z[2], 0]
 QQMPolyRingElem[-t[1] - z[2] + z[3], -z[2] + z[3], -z[2] + z[3], -t[1] - t[2] - z[2] + z[3], 0]
 QQMPolyRingElem[t[1] - z[3] + z[4], t[1] + t[2] - z[3] + z[4], -z[3] + z[4], -z[3] + z[4], 0]
 QQMPolyRingElem[2*z[1], z[1] + z[2], -t[1] + z[1] + z[3], z[1] + z[4], -2]
```
"""
function computeM1(G::labeledgraph)
    RZ=G.baikovover;
    R=G.over;
    gens_RZ=gens(RZ);
    B=G.baikovmatrix;
    
    C=matrix(RZ, G.baikovmatrix);
    f=det(C);

    npars=0;
    p=gens(base_ring(R));
    para=[];
    for i in 1:length(p) 
    
        if p[i] in inverted_set(R)
            continue;
        else
            push!(para,p[i]); 
            npars=npars+1;
        end
          
    end
    m=length(para);
    E=m;
    m2=Int(m*(m-1)/2);
    mt=0;  
    if m2==0
        mt=1;
    else
        mt=m2-1;
    end
    L=length(p)-E;        
    #----------Getting t vector and z vector-------------
    var_t=Vector{typeof(RZ(1))}(undef,0);
    var_z=Vector{typeof(RZ(1))}(undef,0);
    for i in 1:mt
        push!(var_t,gens_RZ[i]);
    end
    for i in mt+2:length(gens_RZ) #changed 
        push!(var_z,gens_RZ[i]);
    end

    t=[];
   n=L*E+Int(L*(L+1)/2);


##------------Compute the partial derivative correctly z_alpha/x(i,j)-------------------------------
    W=Matrix{typeof(RZ(1))}(undef,length(var_z),length(var_z));    
    r=0;
    ij=[];
    for i in E+1:E+L 
        for j in 1:E+L-1 
            r=r+1;
            push!(ij,[i,j]);
            for l in 1:length(var_z) 
                W[r,l]=derivative(B[i,j],var_z[l]);
            end
        end
    end
    push!(ij,[E+L,E+L])
    for l in 1:length(var_z) 
        W[length(var_z),l]=derivative(B[E+L,E+L],var_z[l]);

    end
    C=matrix(RZ, W)
    C=inv(C);
    for i in E+1:E+L
        for j in 1:E+L
            v=Vector{typeof(RZ(1))}(undef,0);
            for l in 1:n #here l is alpha
                a=RZ(0);
                for k in 1:E+L 
                if i==k
                    d=RZ(2);
                else
                     d=RZ(1);
                end
           
                if findall(x->x==[i,k],ij)!=[]
                    c=C[l,findall(x->x==[i,k],ij)[1]];
                elseif findall(x->x==[k,i],ij)!=[]
                        c=C[l,findall(x->x==[k,i],ij)[1]];
                else
                        c=RZ(0);   
                end
           
                a=a+d*c*B[j,k];
                end   
                push!(v,a);
        
            end
                if i==j
                    b=RZ(-2);
                else
                    b=RZ(0);
                end
                push!(v,b);
                push!(t,v);
        #   v=Vector{typeof(RZ(1))}(undef,0);
        end 
   
    end
    return t;
end

